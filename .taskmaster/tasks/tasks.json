{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Next.js project with required dependencies and configuration",
        "description": "Set up the foundational Next.js App Router project structure with TypeScript, install all required dependencies (shadcn/ui, TanStack Query, Supabase client, Vitest, Storybook), and configure the development environment according to CLAUDE.md specifications.",
        "details": "1. Initialize Next.js with App Router:\n   pnpm create next-app@latest . --typescript --tailwind --app --src-dir --import-alias \"@/*\"\n\n2. Install core dependencies:\n   pnpm add @supabase/supabase-js @supabase/ssr @tanstack/react-query\n   pnpm add -D supabase --allow-build=supabase\n\n3. Install UI dependencies:\n   pnpm add -D tailwindcss-animate class-variance-authority clsx tailwind-merge lucide-react\n   npx shadcn@latest init (configure for App Router, TypeScript, CSS variables)\n\n4. Install testing dependencies:\n   pnpm add -D vitest @testing-library/react @testing-library/jest-dom @vitejs/plugin-react jsdom\n   pnpm add -D @vitest/ui happy-dom\n\n5. Install Storybook:\n   pnpm dlx storybook@latest init --builder vite\n\n6. Configure vitest.config.ts with React Testing Library setup\n\n7. Configure Next.js config for proper image domains and environment variables\n\n8. Set up DDD directory structure:\n   src/\n     app/            # Next.js App Router pages\n     features/       # Feature modules (chat, auth, profile)\n     infrastructure/ # External service integrations (Supabase)\n     shared/         # Shared utilities, types, UI components\n\n9. Create tsconfig.json path aliases for clean imports",
        "testStrategy": "Verify installation by:\n1. Running pnpm dev successfully\n2. Checking all dependencies are in package.json\n3. Verifying TypeScript compilation with pnpm tsc --noEmit\n4. Running pnpm test (even with no tests yet)\n5. Running pnpm storybook successfully\n6. Confirming directory structure matches DDD/Clean Architecture guidelines",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Set up Supabase local environment and database schema with migrations",
        "description": "Initialize local Supabase instance, create database migrations for profiles and messages tables with proper relationships and RLS policies, configure Storage bucket for avatars, and set up environment variables.",
        "details": "1. Initialize Supabase:\n   npx supabase init\n   npx supabase start\n\n2. Create migration file for profiles table:\n   npx supabase migration new create_profiles_table\n   \n   Migration SQL:\n   ```sql\n   CREATE TABLE profiles (\n     id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,\n     username TEXT NOT NULL,\n     avatar_url TEXT,\n     created_at TIMESTAMPTZ DEFAULT NOW(),\n     updated_at TIMESTAMPTZ DEFAULT NOW()\n   );\n\n   -- Enable RLS\n   ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;\n\n   -- SELECT policy: authenticated users can view all profiles\n   CREATE POLICY \"Profiles are viewable by authenticated users\"\n     ON profiles FOR SELECT\n     TO authenticated\n     USING (true);\n\n   -- UPDATE policy: users can only update their own profile\n   CREATE POLICY \"Users can update own profile\"\n     ON profiles FOR UPDATE\n     TO authenticated\n     USING (auth.uid() = id);\n\n   -- Trigger to auto-update updated_at\n   CREATE OR REPLACE FUNCTION update_updated_at_column()\n   RETURNS TRIGGER AS $$\n   BEGIN\n     NEW.updated_at = NOW();\n     RETURN NEW;\n   END;\n   $$ LANGUAGE plpgsql;\n\n   CREATE TRIGGER update_profiles_updated_at\n     BEFORE UPDATE ON profiles\n     FOR EACH ROW\n     EXECUTE FUNCTION update_updated_at_column();\n   ```\n\n3. Create migration for messages table:\n   npx supabase migration new create_messages_table\n   \n   Migration SQL:\n   ```sql\n   CREATE TABLE messages (\n     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n     user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,\n     content TEXT NOT NULL,\n     created_at TIMESTAMPTZ DEFAULT NOW()\n   );\n\n   -- Index for efficient querying\n   CREATE INDEX messages_created_at_idx ON messages(created_at DESC);\n   CREATE INDEX messages_user_id_idx ON messages(user_id);\n\n   -- Enable RLS\n   ALTER TABLE messages ENABLE ROW LEVEL SECURITY;\n\n   -- SELECT policy: authenticated users can view all messages\n   CREATE POLICY \"Messages are viewable by authenticated users\"\n     ON messages FOR SELECT\n     TO authenticated\n     USING (true);\n\n   -- INSERT policy: authenticated users can insert with their own user_id\n   CREATE POLICY \"Users can insert own messages\"\n     ON messages FOR INSERT\n     TO authenticated\n     WITH CHECK (auth.uid() = user_id);\n\n   -- DELETE policy: users can delete their own messages\n   CREATE POLICY \"Users can delete own messages\"\n     ON messages FOR DELETE\n     TO authenticated\n     USING (auth.uid() = user_id);\n   ```\n\n4. Create migration for avatars storage bucket:\n   npx supabase migration new create_avatars_bucket\n   \n   Migration SQL:\n   ```sql\n   -- Create avatars bucket\n   INSERT INTO storage.buckets (id, name, public)\n   VALUES ('avatars', 'avatars', true);\n\n   -- Storage policies\n   CREATE POLICY \"Avatar images are publicly accessible\"\n     ON storage.objects FOR SELECT\n     USING (bucket_id = 'avatars');\n\n   CREATE POLICY \"Users can upload own avatar\"\n     ON storage.objects FOR INSERT\n     TO authenticated\n     WITH CHECK (\n       bucket_id = 'avatars' AND\n       (storage.foldername(name))[1] = auth.uid()::text\n     );\n\n   CREATE POLICY \"Users can update own avatar\"\n     ON storage.objects FOR UPDATE\n     TO authenticated\n     USING (\n       bucket_id = 'avatars' AND\n       (storage.foldername(name))[1] = auth.uid()::text\n     );\n\n   CREATE POLICY \"Users can delete own avatar\"\n     ON storage.objects FOR DELETE\n     TO authenticated\n     USING (\n       bucket_id = 'avatars' AND\n       (storage.foldername(name))[1] = auth.uid()::text\n     );\n   ```\n\n5. Create migration for profile auto-creation trigger:\n   npx supabase migration new create_profile_on_signup\n   \n   Migration SQL:\n   ```sql\n   -- Function to create profile on user signup\n   CREATE OR REPLACE FUNCTION public.handle_new_user()\n   RETURNS TRIGGER AS $$\n   BEGIN\n     INSERT INTO public.profiles (id, username, avatar_url)\n     VALUES (\n       NEW.id,\n       COALESCE(NEW.raw_user_meta_data->>'name', NEW.email),\n       NEW.raw_user_meta_data->>'avatar_url'\n     );\n     RETURN NEW;\n   END;\n   $$ LANGUAGE plpgsql SECURITY DEFINER;\n\n   -- Trigger on auth.users\n   CREATE TRIGGER on_auth_user_created\n     AFTER INSERT ON auth.users\n     FOR EACH ROW\n     EXECUTE FUNCTION public.handle_new_user();\n   ```\n\n6. Apply migrations:\n   npx supabase migration up\n\n7. Create .env.local:\n   ```\n   NEXT_PUBLIC_SUPABASE_URL=http://localhost:54321\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=<from supabase start output>\n   SUPABASE_SERVICE_ROLE_KEY=<from supabase start output>\n   ```\n\n8. Configure Google OAuth in Supabase Dashboard (http://localhost:54323)",
        "testStrategy": "Verify setup by:\n1. Running npx supabase status - all services should be healthy\n2. Accessing Supabase Studio at http://localhost:54323\n3. Verifying profiles and messages tables exist with correct columns\n4. Checking RLS policies are enabled and configured correctly\n5. Confirming avatars bucket exists in Storage\n6. Testing trigger by manually creating a test user in auth.users and verifying profile auto-creation\n7. Verifying environment variables are loaded in Next.js",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement authentication infrastructure and domain layer",
        "description": "Create Supabase client configuration, authentication service in infrastructure layer, auth domain entities/use cases following DDD principles, and implement Google OAuth login/logout functionality with session management.",
        "details": "1. Create Supabase client utilities in infrastructure layer:\n   src/infrastructure/supabase/client.ts (browser client)\n   src/infrastructure/supabase/server.ts (server client with cookies)\n   src/infrastructure/supabase/middleware.ts (Next.js middleware for auth)\n\n   Implementation:\n   ```typescript\n   // client.ts - Browser client\n   import { createBrowserClient } from '@supabase/ssr'\n   export const createClient = () => createBrowserClient(\n     process.env.NEXT_PUBLIC_SUPABASE_URL!,\n     process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n   )\n\n   // server.ts - Server-side client\n   import { createServerClient } from '@supabase/ssr'\n   import { cookies } from 'next/headers'\n   export const createClient = () => {\n     const cookieStore = cookies()\n     return createServerClient(\n       process.env.NEXT_PUBLIC_SUPABASE_URL!,\n       process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n       { cookies: { get, set, remove } handlers }\n     )\n   }\n   ```\n\n2. Create auth domain layer:\n   src/features/auth/domain/entities/user.ts\n   src/features/auth/domain/repositories/auth-repository.ts (interface)\n   src/features/auth/domain/use-cases/sign-in-with-google.ts\n   src/features/auth/domain/use-cases/sign-out.ts\n   src/features/auth/domain/use-cases/get-current-user.ts\n\n   Entity example:\n   ```typescript\n   export type User = {\n     id: string\n     email: string\n     username: string\n     avatarUrl: string | null\n   }\n   ```\n\n3. Implement auth repository in infrastructure:\n   src/features/auth/infrastructure/supabase-auth-repository.ts\n   \n   Methods:\n   - signInWithGoogle() - initiates OAuth flow\n   - signOut() - clears session\n   - getCurrentUser() - fetches authenticated user\n   - onAuthStateChange() - listens to auth events\n\n4. Create auth context and hooks:\n   src/features/auth/presentation/providers/auth-provider.tsx\n   src/features/auth/presentation/hooks/use-auth.ts\n   src/features/auth/presentation/hooks/use-require-auth.ts\n\n   Provider wraps app with TanStack Query and auth state:\n   ```typescript\n   export function AuthProvider({ children }) {\n     const queryClient = new QueryClient()\n     return (\n       <QueryClientProvider client={queryClient}>\n         <AuthContextProvider>\n           {children}\n         </AuthContextProvider>\n       </QueryClientProvider>\n     )\n   }\n   ```\n\n5. Create login page:\n   src/app/login/page.tsx\n   \n   UI with:\n   - App title/description\n   - Google login button using shadcn Button\n   - Calls signInWithGoogle() on click\n\n6. Create auth callback route:\n   src/app/auth/callback/route.ts\n   \n   Handles OAuth redirect, exchanges code for session\n\n7. Add middleware:\n   src/middleware.ts\n   \n   Refreshes session, redirects unauthenticated users to /login\n\n8. Create logout functionality in header/navigation",
        "testStrategy": "Test authentication flow:\n1. Unit tests for use cases with mocked repository\n2. Integration tests for SupabaseAuthRepository\n3. Manual testing:\n   - Visit /login when logged out\n   - Click Google login button\n   - Verify OAuth flow redirects to Google\n   - Complete Google authentication\n   - Verify redirect back to app with session\n   - Check profile was auto-created in profiles table\n   - Verify session persists on page refresh\n   - Test logout functionality\n   - Verify middleware redirects unauthenticated users\n4. Check auth state with React DevTools\n5. Verify cookies are set correctly",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement profile management feature with avatar upload",
        "description": "Create profile domain layer, repository implementation for profile CRUD operations, avatar upload to Supabase Storage, profile edit UI components, and integrate with shadcn/ui components.",
        "details": "1. Create profile domain layer:\n   src/features/profile/domain/entities/profile.ts\n   ```typescript\n   export type Profile = {\n     id: string\n     username: string\n     avatarUrl: string | null\n     createdAt: Date\n     updatedAt: Date\n   }\n   ```\n\n   src/features/profile/domain/repositories/profile-repository.ts (interface)\n   Methods: getProfile(userId), updateProfile(userId, data), uploadAvatar(userId, file)\n\n   src/features/profile/domain/use-cases/get-profile.ts\n   src/features/profile/domain/use-cases/update-profile.ts\n   src/features/profile/domain/use-cases/upload-avatar.ts\n\n2. Implement profile repository:\n   src/features/profile/infrastructure/supabase-profile-repository.ts\n   \n   Key implementations:\n   - getProfile: SELECT from profiles table\n   - updateProfile: UPDATE profiles with optimistic locking\n   - uploadAvatar: \n     * Generate file path: `{userId}/avatar.{ext}`\n     * Upload to avatars bucket\n     * Update profile.avatar_url with public URL\n     * Handle file size limits (max 2MB)\n\n3. Create profile presentation layer hooks:\n   src/features/profile/presentation/hooks/use-profile.ts\n   ```typescript\n   export function useProfile(userId: string) {\n     return useQuery({\n       queryKey: ['profile', userId],\n       queryFn: () => getProfile(userId)\n     })\n   }\n   ```\n\n   src/features/profile/presentation/hooks/use-update-profile.ts\n   ```typescript\n   export function useUpdateProfile() {\n     const queryClient = useQueryClient()\n     return useMutation({\n       mutationFn: updateProfile,\n       onSuccess: () => {\n         queryClient.invalidateQueries({ queryKey: ['profile'] })\n       }\n     })\n   }\n   ```\n\n   src/features/profile/presentation/hooks/use-upload-avatar.ts (similar pattern)\n\n4. Create shared UI components using shadcn:\n   src/shared/components/ui/avatar.tsx (npx shadcn add avatar)\n   src/shared/components/ui/input.tsx (npx shadcn add input)\n   src/shared/components/ui/button.tsx (npx shadcn add button)\n   src/shared/components/ui/form.tsx (npx shadcn add form)\n   \n5. Create profile-specific components:\n   src/features/profile/presentation/components/profile-avatar.tsx\n   - Displays avatar with fallback to initial\n   - Click to open file picker\n   - Shows upload progress\n\n   src/features/profile/presentation/components/profile-edit-form.tsx\n   - Form with username input\n   - Avatar upload component\n   - Save/Cancel buttons\n   - Form validation with zod\n\n6. Create profile edit page:\n   src/app/profile/edit/page.tsx\n   - Requires authentication (use useRequireAuth)\n   - Loads current user profile\n   - Renders ProfileEditForm\n   - Handles success/error states\n\n7. Create profile display component:\n   src/features/profile/presentation/components/profile-card.tsx\n   - Shows username and avatar\n   - Used in header/navigation\n   - Link to profile edit page\n\n8. Add profile link to header/navigation",
        "testStrategy": "Testing strategy:\n1. Unit tests:\n   - Use cases with mocked repositories\n   - Validation logic for username format\n   - Avatar file type/size validation\n2. Integration tests:\n   - Repository methods with test database\n   - File upload to Storage\n3. Component tests:\n   - ProfileAvatar renders correctly\n   - ProfileEditForm submission\n   - Form validation errors display\n4. Manual testing:\n   - Edit profile page loads current data\n   - Update username and save\n   - Upload avatar image (test various formats)\n   - Verify avatar displays in header\n   - Test avatar URL generation\n   - Check profile updates reflect in database\n   - Test file size limit enforcement\n5. Accessibility testing:\n   - Form labels and ARIA attributes\n   - Keyboard navigation\n   - Screen reader compatibility",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement real-time chat feature with message CRUD and subscriptions",
        "description": "Create chat domain layer with message entities, implement repository with Supabase real-time subscriptions, build chat UI with message list and input form, handle optimistic updates, and display user avatars/names.",
        "details": "1. Create chat domain layer:\n   src/features/chat/domain/entities/message.ts\n   ```typescript\n   export type Message = {\n     id: string\n     userId: string\n     content: string\n     createdAt: Date\n     author: {\n       username: string\n       avatarUrl: string | null\n     }\n   }\n   ```\n\n   src/features/chat/domain/repositories/message-repository.ts (interface)\n   Methods: getMessages(), sendMessage(content), deleteMessage(id), subscribeToMessages(callback)\n\n   src/features/chat/domain/use-cases/get-messages.ts\n   src/features/chat/domain/use-cases/send-message.ts\n   src/features/chat/domain/use-cases/delete-message.ts\n   src/features/chat/domain/use-cases/subscribe-to-messages.ts\n\n2. Implement message repository:\n   src/features/chat/infrastructure/supabase-message-repository.ts\n   \n   Key implementations:\n   - getMessages: \n     ```sql\n     SELECT m.*, p.username, p.avatar_url\n     FROM messages m\n     JOIN profiles p ON m.user_id = p.id\n     ORDER BY m.created_at DESC\n     LIMIT 100\n     ```\n   - sendMessage: INSERT with user_id from auth\n   - deleteMessage: DELETE WHERE id = ? AND user_id = auth.uid()\n   - subscribeToMessages:\n     ```typescript\n     supabase\n       .channel('messages')\n       .on('postgres_changes', {\n         event: '*',\n         schema: 'public',\n         table: 'messages'\n       }, handleChange)\n       .subscribe()\n     ```\n\n3. Create presentation hooks:\n   src/features/chat/presentation/hooks/use-messages.ts\n   ```typescript\n   export function useMessages() {\n     const queryClient = useQueryClient()\n     \n     // Query for initial messages\n     const query = useQuery({\n       queryKey: ['messages'],\n       queryFn: getMessages\n     })\n\n     // Subscribe to real-time updates\n     useEffect(() => {\n       const subscription = subscribeToMessages((payload) => {\n         queryClient.invalidateQueries({ queryKey: ['messages'] })\n       })\n       return () => subscription.unsubscribe()\n     }, [])\n\n     return query\n   }\n   ```\n\n   src/features/chat/presentation/hooks/use-send-message.ts\n   ```typescript\n   export function useSendMessage() {\n     const queryClient = useQueryClient()\n     return useMutation({\n       mutationFn: sendMessage,\n       onMutate: async (content) => {\n         // Optimistic update\n         await queryClient.cancelQueries({ queryKey: ['messages'] })\n         const previous = queryClient.getQueryData(['messages'])\n         queryClient.setQueryData(['messages'], (old) => [\n           ...old,\n           { id: 'temp', content, createdAt: new Date(), /* ... */ }\n         ])\n         return { previous }\n       },\n       onError: (err, variables, context) => {\n         queryClient.setQueryData(['messages'], context.previous)\n       },\n       onSuccess: () => {\n         queryClient.invalidateQueries({ queryKey: ['messages'] })\n       }\n     })\n   }\n   ```\n\n   src/features/chat/presentation/hooks/use-delete-message.ts (similar pattern)\n\n4. Create chat UI components:\n   Install shadcn components:\n   npx shadcn add textarea\n   npx shadcn add scroll-area\n   npx shadcn add dropdown-menu\n\n   src/features/chat/presentation/components/message-item.tsx\n   - Avatar (from ProfileAvatar component)\n   - Username and timestamp\n   - Message content\n   - Delete button (only for own messages)\n   - Styling for own vs others' messages\n\n   src/features/chat/presentation/components/message-list.tsx\n   - ScrollArea with auto-scroll to bottom\n   - Maps messages to MessageItem\n   - Loading/empty states\n   - Virtualization for performance (optional)\n\n   src/features/chat/presentation/components/message-input.tsx\n   - Textarea for message content\n   - Send button (disabled when empty)\n   - Enter key to send (Shift+Enter for new line)\n   - Character limit indicator\n   - Loading state during send\n\n5. Create chat page:\n   src/app/chat/page.tsx or src/app/page.tsx (as main page)\n   - Layout with header (profile, logout)\n   - MessageList component\n   - MessageInput component\n   - Real-time connection indicator\n\n6. Add proper error handling:\n   - Network errors\n   - Permission errors (RLS violations)\n   - Connection loss/recovery\n   - Toast notifications for errors (npx shadcn add toast)\n\n7. Implement message formatting:\n   - Auto-link URLs\n   - Preserve line breaks\n   - XSS protection (sanitize content)\n\n8. Add date separators in message list",
        "testStrategy": "Comprehensive testing:\n1. Unit tests:\n   - Use cases with mocked repository\n   - Message content validation\n   - XSS sanitization\n2. Integration tests:\n   - Message CRUD operations\n   - Real-time subscription updates\n   - Multi-user message flow\n3. Component tests:\n   - MessageItem renders correctly\n   - MessageInput validation\n   - Delete button only shows for own messages\n   - Auto-scroll behavior\n4. Real-time testing:\n   - Open app in two browser windows\n   - Send message in window 1\n   - Verify appears in window 2 immediately\n   - Test message deletion propagation\n   - Test connection recovery after network interruption\n5. Manual testing:\n   - Send various message types (short, long, multi-line)\n   - Test Enter/Shift+Enter behavior\n   - Verify timestamps display correctly\n   - Check avatar and username display\n   - Test delete message functionality\n   - Verify RLS policies prevent unauthorized deletes\n   - Test with 10+ concurrent users\n6. Performance testing:\n   - Load 100+ messages\n   - Check scroll performance\n   - Monitor memory usage with subscriptions",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement comprehensive testing, Storybook documentation, and production optimizations",
        "description": "Set up complete test coverage using Vitest for all layers (domain, infrastructure, presentation), create Storybook stories for UI components, implement error boundaries, loading states, SEO optimization, and prepare for production deployment.",
        "details": "1. Set up comprehensive test infrastructure:\n   vitest.config.ts - configure test environment, coverage\n   src/shared/testing/setup.ts - global test setup\n   src/shared/testing/mocks/ - mock factories for entities\n   src/shared/testing/test-utils.tsx - custom render with providers\n\n2. Write domain layer tests:\n   src/features/auth/domain/use-cases/__tests__/\n   src/features/profile/domain/use-cases/__tests__/\n   src/features/chat/domain/use-cases/__tests__/\n   - Test all use cases with mocked repositories\n   - Test validation logic\n   - Test error handling\n   - Aim for 90%+ coverage on domain layer\n\n3. Write infrastructure layer tests:\n   src/features/*/infrastructure/__tests__/\n   - Test repository implementations with test Supabase instance\n   - Test real-time subscription handling\n   - Test file upload logic\n   - Mock Supabase client for unit tests\n\n4. Write presentation layer tests:\n   src/features/*/presentation/components/__tests__/\n   src/features/*/presentation/hooks/__tests__/\n   - Test component rendering with React Testing Library\n   - Test user interactions (click, type, submit)\n   - Test hook behavior with renderHook\n   - Test optimistic updates\n   - Test error states\n\n5. Set up Storybook stories:\n   .storybook/main.ts - configure Vite builder\n   .storybook/preview.tsx - global decorators, themes\n   \n   Create stories for all UI components:\n   src/shared/components/ui/*.stories.tsx\n   src/features/*/presentation/components/*.stories.tsx\n   \n   Story examples:\n   - MessageItem: normal, own message, with/without avatar, long text\n   - ProfileAvatar: with image, without image, loading\n   - MessageInput: empty, with text, disabled, error\n   - ProfileEditForm: initial state, editing, submitting, error\n   \n   Use Storybook actions for event handlers\n   Use Storybook controls for props\n\n6. Add accessibility testing to Storybook:\n   pnpm add -D @storybook/addon-a11y\n   Configure a11y addon in .storybook/main.ts\n\n7. Implement error boundaries:\n   src/shared/components/error-boundary.tsx\n   - Catch React errors\n   - Display user-friendly error message\n   - Log to error tracking (optional)\n   - Reset button to recover\n   \n   Wrap app and feature sections with error boundaries\n\n8. Add loading states and skeletons:\n   src/shared/components/ui/skeleton.tsx (npx shadcn add skeleton)\n   - Loading skeleton for message list\n   - Loading skeleton for profile\n   - Suspense boundaries for async components\n\n9. Implement SEO optimization:\n   src/app/layout.tsx - metadata, viewport\n   src/app/page.tsx - Open Graph tags\n   - Proper page titles\n   - Meta descriptions\n   - Open Graph images\n\n10. Add production optimizations:\n   - next.config.js: enable compression, optimize images\n   - Implement React.memo for expensive components\n   - Code splitting for feature modules\n   - Lazy load non-critical components\n   - Configure Supabase connection pooling\n\n11. Create comprehensive E2E test (optional but recommended):\n   Install Playwright: pnpm add -D @playwright/test\n   tests/e2e/chat-flow.spec.ts:\n   - Login → Edit profile → Send message → Delete message → Logout\n\n12. Add performance monitoring:\n   - Web Vitals tracking\n   - Supabase query performance logging\n   - Real-time connection health monitoring\n\n13. Create documentation:\n   docs/ARCHITECTURE.md - explain DDD/Clean Architecture structure\n   docs/TESTING.md - testing guidelines and examples\n   docs/DEPLOYMENT.md - deployment instructions\n\n14. Set up CI/CD preparation:\n   .github/workflows/test.yml - run tests on PR\n   .github/workflows/lint.yml - ESLint and TypeScript checks\n   Add npm scripts:\n   - pnpm test:coverage\n   - pnpm lint\n   - pnpm build\n   - pnpm type-check\n\n15. Create production environment setup guide:\n   - Supabase project creation\n   - Environment variables for production\n   - Google OAuth configuration\n   - Migration deployment process",
        "testStrategy": "Final validation checklist:\n1. Run full test suite:\n   - pnpm test:coverage (target >80% coverage)\n   - pnpm test:integration\n   - pnpm test:e2e (if implemented)\n2. Run production build:\n   - pnpm build (no errors)\n   - pnpm start (verify production mode)\n3. Storybook verification:\n   - pnpm build-storybook\n   - Check all components render\n   - Verify a11y checks pass\n4. Manual testing checklist:\n   - Complete user flow: login → profile edit → chat → logout\n   - Test on Chrome desktop (primary target)\n   - Test with 10 concurrent users\n   - Test network interruption recovery\n   - Test all error states\n   - Verify responsive behavior\n5. Performance audit:\n   - Lighthouse score (target >90)\n   - Web Vitals within thresholds\n   - Bundle size analysis\n6. Security audit:\n   - RLS policies tested\n   - XSS protection verified\n   - CSRF protection (built into Supabase)\n   - Environment variables not exposed\n7. Accessibility audit:\n   - Keyboard navigation works\n   - Screen reader compatibility\n   - Color contrast meets WCAG AA\n8. Documentation review:\n   - README complete\n   - Architecture docs accurate\n   - Deployment guide tested\n9. Production readiness:\n   - Error boundaries tested\n   - Loading states polished\n   - SEO metadata complete\n   - Analytics ready (if needed)",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-12-16T14:52:05.236Z",
      "updated": "2025-12-16T14:52:05.236Z",
      "description": "Tasks for master context"
    }
  }
}