{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Next.js project with required dependencies and configuration",
        "description": "Set up the foundational Next.js App Router project structure with TypeScript, install all required dependencies (shadcn/ui, TanStack Query, Supabase client, Vitest, Storybook), and configure the development environment according to CLAUDE.md specifications.",
        "details": "1. Initialize Next.js with App Router:\n   pnpm create next-app@latest . --typescript --tailwind --app --src-dir --import-alias \"@/*\"\n\n2. Install core dependencies:\n   pnpm add @supabase/supabase-js @supabase/ssr @tanstack/react-query\n   pnpm add -D supabase --allow-build=supabase\n\n3. Install UI dependencies:\n   pnpm add -D tailwindcss-animate class-variance-authority clsx tailwind-merge lucide-react\n   npx shadcn@latest init (configure for App Router, TypeScript, CSS variables)\n\n4. Install testing dependencies:\n   pnpm add -D vitest @testing-library/react @testing-library/jest-dom @vitejs/plugin-react jsdom\n   pnpm add -D @vitest/ui happy-dom\n\n5. Install Storybook:\n   pnpm dlx storybook@latest init --builder vite\n\n6. Configure vitest.config.ts with React Testing Library setup\n\n7. Configure Next.js config for proper image domains and environment variables\n\n8. Set up DDD directory structure:\n   src/\n     app/            # Next.js App Router pages\n     features/       # Feature modules (chat, auth, profile)\n     infrastructure/ # External service integrations (Supabase)\n     shared/         # Shared utilities, types, UI components\n\n9. Create tsconfig.json path aliases for clean imports",
        "testStrategy": "Verify installation by:\n1. Running pnpm dev successfully\n2. Checking all dependencies are in package.json\n3. Verifying TypeScript compilation with pnpm tsc --noEmit\n4. Running pnpm test (even with no tests yet)\n5. Running pnpm storybook successfully\n6. Confirming directory structure matches DDD/Clean Architecture guidelines",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Next.js App Router project with TypeScript and Tailwind CSS",
            "description": "Run pnpm create next-app to initialize the Next.js project with App Router, TypeScript, Tailwind CSS, src directory, and path aliases. Configure basic project structure.",
            "dependencies": [],
            "details": "Execute: pnpm create next-app@latest . --typescript --tailwind --app --src-dir --import-alias \"@/*\"\n\nConfiguration choices during setup:\n- TypeScript: Yes\n- ESLint: Yes\n- Tailwind CSS: Yes\n- src/ directory: Yes\n- App Router: Yes\n- Import alias: @/*\n- Turbopack: No (use default webpack for stability)\n\nThis creates:\n- src/app/ directory for App Router pages\n- tsconfig.json with path aliases\n- tailwind.config.ts\n- next.config.js\n- package.json with Next.js, React, and Tailwind dependencies\n\nVerify by checking that pnpm dev can start successfully.",
            "status": "done",
            "testStrategy": "Verification steps:\n1. Run pnpm dev and access http://localhost:3000\n2. Confirm default Next.js welcome page loads\n3. Check src/app/page.tsx exists and renders\n4. Verify tsconfig.json has \"@/*\" path alias configured\n5. Confirm Tailwind classes work by inspecting existing components",
            "updatedAt": "2025-12-17T07:37:55.443Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Install Supabase, TanStack Query, and shadcn/ui dependencies",
            "description": "Install all core dependencies for Supabase client, TanStack Query for data fetching, and shadcn/ui component library with required utilities.",
            "dependencies": [
              1
            ],
            "details": "Install Supabase dependencies:\npnpm add @supabase/supabase-js @supabase/ssr\npnpm add -D supabase --allow-build=supabase\n\nInstall TanStack Query:\npnpm add @tanstack/react-query\n\nInstall shadcn/ui prerequisites:\npnpm add -D tailwindcss-animate class-variance-authority clsx tailwind-merge lucide-react\n\nInitialize shadcn/ui:\nnpx shadcn@latest init\n\nConfiguration for shadcn init:\n- Style: Default\n- Base color: Slate\n- CSS variables: Yes\n- Use src/ directory: Yes\n- Import alias for components: @/components\n- Import alias for utils: @/lib/utils\n- React Server Components: Yes\n- Write config files: Yes\n\nThis creates:\n- components.json for shadcn configuration\n- src/lib/utils.ts with cn() utility\n- Updated tailwind.config.ts with shadcn theme\n<info added on 2025-12-17T10:31:04.602Z>\nI'll analyze the codebase to understand the current state and provide an accurate update for this subtask.Implementation completed successfully on 2025-12-17. All dependencies installed as specified: @supabase/supabase-js@2.88.0, @supabase/ssr@0.8.0, supabase CLI@2.67.2, @tanstack/react-query@5.90.12, tailwindcss-animate@1.0.7, class-variance-authority@0.7.1, clsx@2.1.1, tailwind-merge@3.4.0, lucide-react@0.561.0. shadcn/ui initialized with new-york style (not default as originally specified), slate base color, CSS variables enabled, React Server Components enabled. Configuration files created: components.json with proper aliases (@/components, @/lib/utils, @/components/ui), src/lib/utils.ts with cn() utility function working correctly. Validation test passed: button component successfully installed via npx shadcn@latest add button, created src/components/ui/button.tsx with full TypeScript types, variant system (default, destructive, outline, secondary, ghost, link), size variants (default, sm, lg, icon), and proper integration with @radix-ui/react-slot for composition.\n</info added on 2025-12-17T10:31:04.602Z>",
            "status": "done",
            "testStrategy": "Verification steps:\n1. Check package.json contains all installed dependencies\n2. Verify components.json exists with correct configuration\n3. Confirm src/lib/utils.ts exists with cn() function\n4. Run pnpm install to ensure lock file is updated\n5. Test shadcn by installing a test component: npx shadcn@latest add button\n6. Verify button component is added to src/components/ui/",
            "parentId": "undefined",
            "updatedAt": "2025-12-17T10:24:48.192Z"
          },
          {
            "id": 3,
            "title": "Install and configure Vitest testing framework",
            "description": "Install Vitest, React Testing Library, and related testing dependencies. Create vitest.config.ts with proper React Testing Library setup for testing DDD/Clean Architecture components.",
            "dependencies": [
              2
            ],
            "details": "Install Vitest dependencies:\npnpm add -D vitest @vitejs/plugin-react jsdom\npnpm add -D @testing-library/react @testing-library/jest-dom @testing-library/user-event\npnpm add -D @vitest/ui happy-dom\n\nCreate vitest.config.ts:\n```typescript\nimport { defineConfig } from 'vitest/config'\nimport react from '@vitejs/plugin-react'\nimport path from 'path'\n\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    environment: 'jsdom',\n    globals: true,\n    setupFiles: './src/test/setup.ts',\n  },\n  resolve: {\n    alias: {\n      '@': path.resolve(__dirname, './src'),\n    },\n  },\n})\n```\n\nCreate src/test/setup.ts:\n```typescript\nimport '@testing-library/jest-dom'\nimport { cleanup } from '@testing-library/react'\nimport { afterEach } from 'vitest'\n\nafterEach(() => {\n  cleanup()\n})\n```\n\nAdd test scripts to package.json:\n\"test\": \"vitest\"\n\"test:ui\": \"vitest --ui\"\n\"test:coverage\": \"vitest --coverage\"\n<info added on 2025-12-17T11:04:14.613Z>\nImplementation completed:\n- Installed Vitest v4.0.16 with @vitejs/plugin-react v5.1.2 and jsdom v27.3.0\n- Installed React Testing Library ecosystem: @testing-library/react v16.3.1, @testing-library/jest-dom v6.9.1, @testing-library/user-event v14.6.1\n- Installed @vitest/ui v4.0.16 and happy-dom v20.0.11 for enhanced testing capabilities\n- Created vitest.config.ts with React plugin, jsdom environment, global test configuration, and path alias (@/ → ./src)\n- Created src/test/setup.ts with @testing-library/jest-dom import and automatic cleanup after each test\n- Added test scripts to package.json: \"test\" (runs vitest), \"test:ui\" (runs Vitest UI), \"test:coverage\" (generates coverage report)\n- Verification completed: Button component tests passing, utils function tests passing, path alias (@/) working correctly, TypeScript compilation successful, Vitest UI accessible at specified port\n</info added on 2025-12-17T11:04:14.613Z>",
            "status": "done",
            "testStrategy": "Verification steps:\n1. Run pnpm test - should start Vitest in watch mode\n2. Create a simple test file to verify setup works\n3. Run pnpm test:ui - should open Vitest UI\n4. Verify @testing-library/jest-dom matchers work\n5. Check that TypeScript recognizes vitest globals\n6. Confirm path aliases (@/*) work in test files",
            "parentId": "undefined",
            "updatedAt": "2025-12-17T11:03:39.290Z"
          },
          {
            "id": 4,
            "title": "Install and configure Storybook with Vite builder",
            "description": "Install Storybook with Vite builder for UI component development and catalog. Configure Storybook to work with Next.js App Router, TypeScript, and Tailwind CSS.",
            "dependencies": [
              3
            ],
            "details": "Install Storybook:\npnpm dlx storybook@latest init --builder vite\n\nDuring initialization:\n- Builder: Vite\n- Framework: React\n- Confirm installation of required dependencies\n\nThis creates:\n- .storybook/ directory with main.ts and preview.ts\n- stories/ directory with example stories\n- Storybook scripts in package.json\n\nConfigure .storybook/preview.ts to import Tailwind:\n```typescript\nimport type { Preview } from '@storybook/react'\nimport '../src/app/globals.css'\n\nconst preview: Preview = {\n  parameters: {\n    controls: {\n      matchers: {\n        color: /(background|color)$/i,\n        date: /Date$/i,\n      },\n    },\n  },\n}\n\nexport default preview\n```\n\nUpdate .storybook/main.ts to resolve path aliases:\n```typescript\nconst config: StorybookConfig = {\n  // ... other config\n  viteFinal: async (config) => {\n    return {\n      ...config,\n      resolve: {\n        alias: {\n          '@': path.resolve(__dirname, '../src'),\n        },\n      },\n    }\n  },\n}\n```\n<info added on 2025-12-17T11:29:50.968Z>\nImplementation completed successfully with the following achievements:\n\n- Storybook v10.1.9 installed using Vite builder with Next.js-Vite framework auto-detection\n- Comprehensive addon suite installed: @chromatic-com/storybook@4.1.3, @storybook/addon-vitest@10.1.9, @storybook/addon-a11y@10.1.9, @storybook/addon-docs@10.1.9, @storybook/addon-onboarding@10.1.9\n- Vitest integration configured: @vitest/browser-playwright@4.0.16, @vitest/coverage-v8@4.0.16, Playwright v1.57.0\n- ESLint automatically updated: eslint-plugin-storybook@10.1.9 added with flat config support\n- Preview configuration (.storybook/preview.ts): Tailwind CSS imported via ../src/app/globals.css, accessibility testing enabled\n- Main configuration (.storybook/main.ts): Path alias (@/ → ../src) configured, ESM directory resolution fixed using fileURLToPath\n- Package.json scripts added: \"storybook\": \"storybook dev -p 6006\", \"build-storybook\": \"storybook build\"\n- Verification completed: http://localhost:6006 running successfully, sample stories (Button, Header, Page) rendering correctly, TypeScript compilation successful, path aliases working as expected\n</info added on 2025-12-17T11:29:50.968Z>",
            "status": "done",
            "testStrategy": "Verification steps:\n1. Run pnpm storybook - should start on port 6006\n2. Access http://localhost:6006 and view example stories\n3. Verify Tailwind CSS styles render correctly\n4. Check that @/ path aliases work in story files\n5. Create a simple story for a shadcn button component\n6. Confirm TypeScript has no errors in .storybook files",
            "parentId": "undefined",
            "updatedAt": "2025-12-17T11:29:15.112Z"
          },
          {
            "id": 5,
            "title": "Create DDD directory structure and configure TypeScript paths",
            "description": "Set up the Domain-Driven Design directory structure following Clean Architecture principles. Create feature module directories, infrastructure layer, and shared utilities. Update tsconfig.json with proper path aliases.",
            "dependencies": [
              4
            ],
            "details": "Create DDD directory structure:\nmkdir -p src/features\nmkdir -p src/infrastructure\nmkdir -p src/shared/types\nmkdir -p src/shared/ui\nmkdir -p src/shared/utils\n\nDirectory structure explanation:\n- src/app/: Next.js App Router pages and layouts (Presentation layer)\n- src/features/: Feature modules organized by domain (chat, auth, profile)\n  - Each feature contains: domain/, application/, presentation/\n- src/infrastructure/: External integrations (Supabase, APIs)\n- src/shared/: Shared code across features\n  - types/: Common TypeScript types\n  - ui/: Shared UI components (from shadcn)\n  - utils/: Utility functions\n\nUpdate tsconfig.json paths:\n```json\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"@/*\": [\"./src/*\"],\n      \"@/features/*\": [\"./src/features/*\"],\n      \"@/infrastructure/*\": [\"./src/infrastructure/*\"],\n      \"@/shared/*\": [\"./src/shared/*\"],\n      \"@/app/*\": [\"./src/app/*\"]\n    }\n  }\n}\n```\n\nCreate README files in key directories explaining structure:\n- src/features/README.md\n- src/infrastructure/README.md\n- src/shared/README.md\n\nMove shadcn components:\nmv src/components/ui src/shared/ui/\nmv src/lib/utils.ts src/shared/utils/cn.ts\n\nUpdate components.json to reflect new paths.\n<info added on 2025-12-17T11:42:34.093Z>\nI'll analyze the codebase to understand the current implementation and generate an accurate update based on the completed work.Based on my analysis of the codebase, here is the new text content to append to the subtask:\n\nImplementation completed successfully with full DDD/Clean Architecture structure. All directories created (src/features/, src/infrastructure/, src/shared/{types,ui,utils,hooks}/). TypeScript configuration updated with comprehensive path aliases in tsconfig.json (lines 21-27): @/*, @/features/*, @/infrastructure/*, @/shared/*, @/app/*. README.md files created in all key directories explaining structure, guidelines, and usage examples. File migration completed: src/lib/utils.ts successfully moved to src/shared/utils/cn.ts. Configuration files updated: components.json (lines 14-19) reflects new path structure with aliases pointing to @/shared/ui and @/shared/utils/cn; .storybook/main.ts (lines 26-33) configured with all path aliases in Vite resolve configuration; vitest.config.ts (lines 47-53) configured with all path aliases for test environment. Development environment verified: TypeScript compilation successful, Next.js dev server runs without errors, Storybook accessible at http://localhost:6007. Architecture fully compliant with CLAUDE.md specifications for Feature-First Development with DDD/Clean Architecture principles.\n</info added on 2025-12-17T11:42:34.093Z>",
            "status": "done",
            "testStrategy": "Verification steps:\n1. Run pnpm tsc --noEmit to verify TypeScript compilation\n2. Confirm all path aliases resolve correctly\n3. Check that imports using @/features/*, @/infrastructure/*, @/shared/* work\n4. Verify shadcn components moved to src/shared/ui/ still work\n5. Test that Next.js dev server runs without errors\n6. Confirm Storybook still works with new paths\n7. Verify Vitest tests can import using new path aliases",
            "parentId": "undefined",
            "updatedAt": "2025-12-17T11:41:42.282Z"
          }
        ],
        "updatedAt": "2025-12-17T11:41:42.282Z"
      },
      {
        "id": 2,
        "title": "Set up Supabase local environment and database schema with migrations",
        "description": "Initialize local Supabase instance, create database migrations for profiles and messages tables with proper relationships and RLS policies, configure Storage bucket for avatars, and set up environment variables.",
        "details": "1. Initialize Supabase:\n   npx supabase init\n   npx supabase start\n\n2. Create migration file for profiles table:\n   npx supabase migration new create_profiles_table\n   \n   Migration SQL:\n   ```sql\n   CREATE TABLE profiles (\n     id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,\n     username TEXT NOT NULL,\n     avatar_url TEXT,\n     created_at TIMESTAMPTZ DEFAULT NOW(),\n     updated_at TIMESTAMPTZ DEFAULT NOW()\n   );\n\n   -- Enable RLS\n   ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;\n\n   -- SELECT policy: authenticated users can view all profiles\n   CREATE POLICY \"Profiles are viewable by authenticated users\"\n     ON profiles FOR SELECT\n     TO authenticated\n     USING (true);\n\n   -- UPDATE policy: users can only update their own profile\n   CREATE POLICY \"Users can update own profile\"\n     ON profiles FOR UPDATE\n     TO authenticated\n     USING (auth.uid() = id);\n\n   -- Trigger to auto-update updated_at\n   CREATE OR REPLACE FUNCTION update_updated_at_column()\n   RETURNS TRIGGER AS $$\n   BEGIN\n     NEW.updated_at = NOW();\n     RETURN NEW;\n   END;\n   $$ LANGUAGE plpgsql;\n\n   CREATE TRIGGER update_profiles_updated_at\n     BEFORE UPDATE ON profiles\n     FOR EACH ROW\n     EXECUTE FUNCTION update_updated_at_column();\n   ```\n\n3. Create migration for messages table:\n   npx supabase migration new create_messages_table\n   \n   Migration SQL:\n   ```sql\n   CREATE TABLE messages (\n     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n     user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,\n     content TEXT NOT NULL,\n     created_at TIMESTAMPTZ DEFAULT NOW()\n   );\n\n   -- Index for efficient querying\n   CREATE INDEX messages_created_at_idx ON messages(created_at DESC);\n   CREATE INDEX messages_user_id_idx ON messages(user_id);\n\n   -- Enable RLS\n   ALTER TABLE messages ENABLE ROW LEVEL SECURITY;\n\n   -- SELECT policy: authenticated users can view all messages\n   CREATE POLICY \"Messages are viewable by authenticated users\"\n     ON messages FOR SELECT\n     TO authenticated\n     USING (true);\n\n   -- INSERT policy: authenticated users can insert with their own user_id\n   CREATE POLICY \"Users can insert own messages\"\n     ON messages FOR INSERT\n     TO authenticated\n     WITH CHECK (auth.uid() = user_id);\n\n   -- DELETE policy: users can delete their own messages\n   CREATE POLICY \"Users can delete own messages\"\n     ON messages FOR DELETE\n     TO authenticated\n     USING (auth.uid() = user_id);\n   ```\n\n4. Create migration for avatars storage bucket:\n   npx supabase migration new create_avatars_bucket\n   \n   Migration SQL:\n   ```sql\n   -- Create avatars bucket\n   INSERT INTO storage.buckets (id, name, public)\n   VALUES ('avatars', 'avatars', true);\n\n   -- Storage policies\n   CREATE POLICY \"Avatar images are publicly accessible\"\n     ON storage.objects FOR SELECT\n     USING (bucket_id = 'avatars');\n\n   CREATE POLICY \"Users can upload own avatar\"\n     ON storage.objects FOR INSERT\n     TO authenticated\n     WITH CHECK (\n       bucket_id = 'avatars' AND\n       (storage.foldername(name))[1] = auth.uid()::text\n     );\n\n   CREATE POLICY \"Users can update own avatar\"\n     ON storage.objects FOR UPDATE\n     TO authenticated\n     USING (\n       bucket_id = 'avatars' AND\n       (storage.foldername(name))[1] = auth.uid()::text\n     );\n\n   CREATE POLICY \"Users can delete own avatar\"\n     ON storage.objects FOR DELETE\n     TO authenticated\n     USING (\n       bucket_id = 'avatars' AND\n       (storage.foldername(name))[1] = auth.uid()::text\n     );\n   ```\n\n5. Create migration for profile auto-creation trigger:\n   npx supabase migration new create_profile_on_signup\n   \n   Migration SQL:\n   ```sql\n   -- Function to create profile on user signup\n   CREATE OR REPLACE FUNCTION public.handle_new_user()\n   RETURNS TRIGGER AS $$\n   BEGIN\n     INSERT INTO public.profiles (id, username, avatar_url)\n     VALUES (\n       NEW.id,\n       COALESCE(NEW.raw_user_meta_data->>'name', NEW.email),\n       NEW.raw_user_meta_data->>'avatar_url'\n     );\n     RETURN NEW;\n   END;\n   $$ LANGUAGE plpgsql SECURITY DEFINER;\n\n   -- Trigger on auth.users\n   CREATE TRIGGER on_auth_user_created\n     AFTER INSERT ON auth.users\n     FOR EACH ROW\n     EXECUTE FUNCTION public.handle_new_user();\n   ```\n\n6. Apply migrations:\n   npx supabase migration up\n\n7. Create .env.local:\n   ```\n   NEXT_PUBLIC_SUPABASE_URL=http://localhost:54321\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=<from supabase start output>\n   SUPABASE_SERVICE_ROLE_KEY=<from supabase start output>\n   ```\n\n8. Configure Google OAuth in Supabase Dashboard (http://localhost:54323)",
        "testStrategy": "Verify setup by:\n1. Running npx supabase status - all services should be healthy\n2. Accessing Supabase Studio at http://localhost:54323\n3. Verifying profiles and messages tables exist with correct columns\n4. Checking RLS policies are enabled and configured correctly\n5. Confirming avatars bucket exists in Storage\n6. Testing trigger by manually creating a test user in auth.users and verifying profile auto-creation\n7. Verifying environment variables are loaded in Next.js",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Supabase CLI and start local instance",
            "description": "Install Supabase CLI as dev dependency, run supabase init to create configuration, and start local Supabase services including PostgreSQL, Auth, and Storage. [Updated: 2025/12/17]",
            "dependencies": [],
            "details": "Execute the following commands:\n1. pnpm add supabase --save-dev --allow-build=supabase\n2. npx supabase init (creates supabase/config.toml and .gitignore entries)\n3. npx supabase start (starts Docker containers for all Supabase services)\n4. Verify services are running: npx supabase status\n5. Take note of API URL, anon key, and service_role key from output for later use in .env.local\n\nExpected outcome: supabase/ directory created with config.toml, all Docker containers running, Studio accessible at http://localhost:54323\n<info added on 2025-12-17T12:19:37.547Z>\nI'll analyze the codebase to provide specific implementation details about the completed Supabase setup.Successfully implemented Supabase CLI installation and local development environment initialization. Configuration confirmed:\n- Supabase CLI v2.67.2 installed in package.json:62 with pnpm build restriction\n- supabase/config.toml created with project_id \"supabase-chat-app\"\n- All Docker containers running successfully (verified via npx supabase status)\n- Studio accessible at http://127.0.0.1:54323 (port configured in config.toml:85)\n- API URL: http://127.0.0.1:54321\n- Database: postgresql://postgres:postgres@127.0.0.1:54322/postgres\n- Authentication keys obtained: Publishable key (sb_publishable_ACJWlzQHlZjBrEguHvfOxg_3BJgxAaH) and Secret key for future .env.local configuration\n- Realtime enabled (config.toml:76), Storage enabled with 50MiB file limit (config.toml:104-106), Auth enabled with site_url configured for http://127.0.0.1:3000 (config.toml:148)\n- Next step: Create .env.local with obtained keys and proceed to subtask 2.2 for profiles table migration\n</info added on 2025-12-17T12:19:37.547Z>",
            "status": "done",
            "testStrategy": "Run 'npx supabase status' and verify all services show as 'healthy'. Access http://localhost:54323 to confirm Supabase Studio is accessible.",
            "parentId": "undefined",
            "updatedAt": "2025-12-17T12:18:33.967Z"
          },
          {
            "id": 2,
            "title": "Create profiles table migration with RLS policies",
            "description": "Generate migration for profiles table with proper schema, foreign key to auth.users, RLS policies for viewing and updating profiles, and auto-update trigger for updated_at timestamp.",
            "dependencies": [
              1
            ],
            "details": "1. Create migration: npx supabase migration new create_profiles_table\n2. Edit the generated file in supabase/migrations/ with SQL:\n   - CREATE TABLE profiles with columns: id (UUID PRIMARY KEY), username (TEXT NOT NULL), avatar_url (TEXT), created_at (TIMESTAMPTZ), updated_at (TIMESTAMPTZ)\n   - Add foreign key: id REFERENCES auth.users(id) ON DELETE CASCADE\n   - Enable RLS: ALTER TABLE profiles ENABLE ROW LEVEL SECURITY\n   - Create SELECT policy: authenticated users can view all profiles\n   - Create UPDATE policy: users can only update their own profile (auth.uid() = id)\n   - Create update_updated_at_column() function and trigger\n3. Apply migration: npx supabase migration up\n\nExpected outcome: profiles table exists with proper constraints, RLS enabled, and working triggers\n<info added on 2025-12-17T13:01:22.491Z>\nI need to analyze the codebase to understand the current state of the Supabase setup and confirm the implementation details mentioned in the user request.Based on my analysis of the codebase, I can confirm the implementation. The migration file `20251217125116_create_profiles_table.sql` exists and contains:\n\n- profiles table with all required columns (id, username, avatar_url, created_at, updated_at)\n- Foreign key constraint to auth.users(id) with ON DELETE CASCADE\n- RLS enabled on the table\n- Three RLS policies: SELECT (all authenticated users), UPDATE (own profile only), INSERT (own profile only)\n- handle_updated_at() function and trigger for automatic updated_at timestamp updates\n\nThe migration was successfully applied via `npx supabase db reset`.\n\nHere is the update content:\n\nImplementation completed successfully. Migration file created at supabase/migrations/20251217125116_create_profiles_table.sql with complete schema including:\n- profiles table structure (id UUID PRIMARY KEY, username TEXT NOT NULL, avatar_url TEXT, created_at/updated_at TIMESTAMPTZ)\n- Foreign key constraint: id REFERENCES auth.users(id) ON DELETE CASCADE\n- RLS enabled with three policies: profiles_select_policy (authenticated users can view all), profiles_update_policy (users can only update own profile using auth.uid()), profiles_insert_policy (users can only insert own profile)\n- handle_updated_at() function and profiles_updated_at_trigger for automatic timestamp updates\nMigration applied successfully to local Supabase instance. Table verified to exist in public schema with all constraints, policies, and triggers active.\n</info added on 2025-12-17T13:01:22.491Z>",
            "status": "done",
            "testStrategy": "Query profiles table in Studio to verify schema. Test RLS by attempting SELECT as authenticated user and UPDATE with different user IDs. Verify trigger updates updated_at on UPDATE.",
            "parentId": "undefined",
            "updatedAt": "2025-12-17T13:00:08.538Z"
          },
          {
            "id": 3,
            "title": "Create messages table migration with indexes and RLS policies",
            "description": "Generate migration for messages table with efficient indexes, foreign key relationship to profiles, and RLS policies for viewing, inserting, and deleting messages based on authentication.",
            "dependencies": [
              2
            ],
            "details": "1. Create migration: npx supabase migration new create_messages_table\n2. Edit migration file with SQL:\n   - CREATE TABLE messages: id (UUID PRIMARY KEY DEFAULT gen_random_uuid()), user_id (UUID NOT NULL), content (TEXT NOT NULL), created_at (TIMESTAMPTZ DEFAULT NOW())\n   - Add foreign key: user_id REFERENCES profiles(id) ON DELETE CASCADE\n   - Create indexes: messages_created_at_idx (created_at DESC), messages_user_id_idx (user_id)\n   - Enable RLS: ALTER TABLE messages ENABLE ROW LEVEL SECURITY\n   - Create SELECT policy: authenticated users can view all messages\n   - Create INSERT policy: authenticated users can insert with their own user_id (auth.uid() = user_id)\n   - Create DELETE policy: users can delete only their own messages\n3. Apply migration: npx supabase migration up\n\nExpected outcome: messages table with proper indexes, foreign key cascade, and RLS policies enforcing ownership\n<info added on 2025-12-17T15:18:46.874Z>\nI need to analyze the codebase to understand the current state of the messages table migration before generating the update text.Based on my analysis of the codebase, I can see that the messages table migration has been successfully created and applied. The migration file `20251217150417_create_messages_table.sql` contains all the required elements, and the database verification confirms that:\n\n1. The `messages` table exists in the `public` schema with the correct structure (id, user_id, content, created_at)\n2. The foreign key constraint to `profiles(id)` with CASCADE DELETE is in place\n3. Both indexes are created: `messages_created_at_idx` (DESC) and `messages_user_id_idx`\n4. RLS is enabled with all three policies properly configured and active\n\nHere is the new text content to append to the subtask:\n\n---\n\nImplementation completed successfully. Migration file created at supabase/migrations/20251217150417_create_messages_table.sql with all required specifications. Database verification confirmed: messages table structure matches design (id UUID PRIMARY KEY with gen_random_uuid(), user_id UUID NOT NULL, content TEXT NOT NULL, created_at TIMESTAMPTZ with NOW() default), foreign key constraint to profiles(id) with ON DELETE CASCADE is active, both indexes created and operational (messages_created_at_idx with DESC ordering, messages_user_id_idx), RLS enabled on table, and all three security policies active and enforcing correctly (SELECT policy allows all authenticated users to view messages with USING true, INSERT policy restricts to auth.uid() = user_id via WITH CHECK clause, DELETE policy restricts to auth.uid() = user_id via USING clause). Migration applied to local database without errors.\n</info added on 2025-12-17T15:18:46.874Z>",
            "status": "done",
            "testStrategy": "Verify table schema and indexes in Studio. Test RLS: INSERT message with correct user_id should succeed, with different user_id should fail. DELETE should only work for own messages.",
            "parentId": "undefined",
            "updatedAt": "2025-12-17T15:17:05.067Z"
          },
          {
            "id": 4,
            "title": "Create avatars storage bucket migration with access policies",
            "description": "Generate migration to create public avatars storage bucket with RLS policies allowing public read access and authenticated user upload/update/delete for their own avatars using folder-based access control.",
            "dependencies": [
              2
            ],
            "details": "1. Create migration: npx supabase migration new create_avatars_bucket\n2. Edit migration file with SQL:\n   - INSERT INTO storage.buckets: id='avatars', name='avatars', public=true\n   - Create SELECT policy on storage.objects: public access for bucket_id='avatars'\n   - Create INSERT policy: authenticated users can upload to avatars/{auth.uid()}/*\n   - Create UPDATE policy: users can update files in their own folder (storage.foldername(name))[1] = auth.uid()::text\n   - Create DELETE policy: users can delete files in their own folder\n3. Apply migration: npx supabase migration up\n\nExpected outcome: avatars bucket visible in Studio Storage, policies enforce folder-based access control per user\n<info added on 2025-12-17T15:25:56.552Z>\nI'll analyze the codebase to provide accurate implementation details for this subtask update.Based on the codebase analysis, here's the new text content that should be appended to the subtask's details:\n\nImplementation completed successfully. Migration file created at supabase/migrations/20251217152422_create_avatars_bucket.sql with the following SQL implementation:\n- INSERT INTO storage.buckets statement creates public avatars bucket (id='avatars', name='avatars', public=true)\n- Four storage policies created on storage.objects table:\n  1. \"Avatar images are publicly accessible\" - SELECT policy for public read access (bucket_id='avatars')\n  2. \"Users can upload own avatar\" - INSERT policy for authenticated users, enforces folder structure avatars/{auth.uid()}/* using (storage.foldername(name))[1] = auth.uid()::text\n  3. \"Users can update own avatar\" - UPDATE policy for authenticated users to modify files in their own folder\n  4. \"Users can delete own avatar\" - DELETE policy for authenticated users to remove files in their own folder\nMigration successfully applied to local Supabase instance. Verified avatars bucket is visible in Supabase Studio at http://127.0.0.1:54323, and all four RLS policies are active and enforcing folder-based access control per user ID.\n</info added on 2025-12-17T15:25:56.552Z>",
            "status": "done",
            "testStrategy": "In Studio Storage, verify avatars bucket exists and is public. Test upload to avatars/{user_id}/test.jpg should succeed for authenticated user, upload to avatars/{other_user_id}/ should fail.",
            "parentId": "undefined",
            "updatedAt": "2025-12-17T15:25:13.340Z"
          },
          {
            "id": 5,
            "title": "Create profile auto-creation trigger and environment variables",
            "description": "Generate migration for automatic profile creation on user signup using auth trigger, configure .env.local with Supabase credentials, and document Google OAuth setup in Studio.",
            "dependencies": [
              2
            ],
            "details": "1. Create migration: npx supabase migration new create_profile_on_signup\n2. Edit migration file with SQL:\n   - CREATE FUNCTION handle_new_user() that INSERTs into profiles using NEW.id, NEW.raw_user_meta_data->>'name' or NEW.email for username, and NEW.raw_user_meta_data->>'avatar_url'\n   - Function should be SECURITY DEFINER to bypass RLS\n   - CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users\n3. Apply migration: npx supabase migration up\n4. Create .env.local file:\n   NEXT_PUBLIC_SUPABASE_URL=http://localhost:54321\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=<from supabase status>\n   SUPABASE_SERVICE_ROLE_KEY=<from supabase status>\n5. Add .env.local to .gitignore if not already present\n6. Document in README or comments: Google OAuth setup requires configuring provider in Studio (http://localhost:54323) under Authentication > Providers\n\nExpected outcome: New auth users automatically get profile entries, environment variables ready for Next.js app\n<info added on 2025-12-17T15:37:30.211Z>\nImplementation completed with the following changes:\n\n**Migration File Created:**\n- File: `supabase/migrations/20251217153450_create_profile_on_signup.sql`\n- Function `handle_new_user()` implemented with SECURITY DEFINER to bypass RLS\n- Extracts username from `raw_user_meta_data->>'name'` or falls back to email\n- Extracts avatar_url from `raw_user_meta_data->>'avatar_url'`\n- Trigger `on_auth_user_created` configured to fire AFTER INSERT ON auth.users\n\n**Environment Configuration:**\n- `.env.local` file created with required variables:\n  - NEXT_PUBLIC_SUPABASE_URL: http://localhost:54321\n  - NEXT_PUBLIC_SUPABASE_ANON_KEY: (populated from supabase status)\n  - SUPABASE_SERVICE_ROLE_KEY: (populated from supabase status)\n- File confirmed in .gitignore to prevent credential exposure\n\n**Documentation Updated:**\n- README.md enhanced with comprehensive setup instructions:\n  - Local Supabase startup procedure\n  - Migration application steps\n  - Environment variable configuration guide\n  - Google OAuth provider setup instructions with Studio URL (http://localhost:54323)\n  - Authentication > Providers configuration steps\n\n**Verification:**\n- Migration successfully applied with `npx supabase migration up`\n- Trigger and function tested and confirmed operational\n- Auto-profile creation verified for new auth.users records\n</info added on 2025-12-17T15:37:30.211Z>",
            "status": "done",
            "testStrategy": "Create test user via Studio Auth and verify profile is auto-created. Check .env.local exists and has correct values. Run 'npx supabase status' and compare keys match .env.local.",
            "parentId": "undefined",
            "updatedAt": "2025-12-17T15:37:02.352Z"
          }
        ],
        "updatedAt": "2025-12-17T15:37:02.352Z"
      },
      {
        "id": 3,
        "title": "Implement authentication infrastructure and domain layer",
        "description": "Create Supabase client configuration, authentication service in infrastructure layer, auth domain entities/use cases following DDD principles, and implement Google OAuth login/logout functionality with session management.",
        "details": "1. Create Supabase client utilities in infrastructure layer:\n   src/infrastructure/supabase/client.ts (browser client)\n   src/infrastructure/supabase/server.ts (server client with cookies)\n   src/infrastructure/supabase/middleware.ts (Next.js middleware for auth)\n\n   Implementation:\n   ```typescript\n   // client.ts - Browser client\n   import { createBrowserClient } from '@supabase/ssr'\n   export const createClient = () => createBrowserClient(\n     process.env.NEXT_PUBLIC_SUPABASE_URL!,\n     process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n   )\n\n   // server.ts - Server-side client\n   import { createServerClient } from '@supabase/ssr'\n   import { cookies } from 'next/headers'\n   export const createClient = () => {\n     const cookieStore = cookies()\n     return createServerClient(\n       process.env.NEXT_PUBLIC_SUPABASE_URL!,\n       process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n       { cookies: { get, set, remove } handlers }\n     )\n   }\n   ```\n\n2. Create auth domain layer:\n   src/features/auth/domain/entities/user.ts\n   src/features/auth/domain/repositories/auth-repository.ts (interface)\n   src/features/auth/domain/use-cases/sign-in-with-google.ts\n   src/features/auth/domain/use-cases/sign-out.ts\n   src/features/auth/domain/use-cases/get-current-user.ts\n\n   Entity example:\n   ```typescript\n   export type User = {\n     id: string\n     email: string\n     username: string\n     avatarUrl: string | null\n   }\n   ```\n\n3. Implement auth repository in infrastructure:\n   src/features/auth/infrastructure/supabase-auth-repository.ts\n   \n   Methods:\n   - signInWithGoogle() - initiates OAuth flow\n   - signOut() - clears session\n   - getCurrentUser() - fetches authenticated user\n   - onAuthStateChange() - listens to auth events\n\n4. Create auth context and hooks:\n   src/features/auth/presentation/providers/auth-provider.tsx\n   src/features/auth/presentation/hooks/use-auth.ts\n   src/features/auth/presentation/hooks/use-require-auth.ts\n\n   Provider wraps app with TanStack Query and auth state:\n   ```typescript\n   export function AuthProvider({ children }) {\n     const queryClient = new QueryClient()\n     return (\n       <QueryClientProvider client={queryClient}>\n         <AuthContextProvider>\n           {children}\n         </AuthContextProvider>\n       </QueryClientProvider>\n     )\n   }\n   ```\n\n5. Create login page:\n   src/app/login/page.tsx\n   \n   UI with:\n   - App title/description\n   - Google login button using shadcn Button\n   - Calls signInWithGoogle() on click\n\n6. Create auth callback route:\n   src/app/auth/callback/route.ts\n   \n   Handles OAuth redirect, exchanges code for session\n\n7. Add middleware:\n   src/middleware.ts\n   \n   Refreshes session, redirects unauthenticated users to /login\n\n8. Create logout functionality in header/navigation",
        "testStrategy": "Test authentication flow:\n1. Unit tests for use cases with mocked repository\n2. Integration tests for SupabaseAuthRepository\n3. Manual testing:\n   - Visit /login when logged out\n   - Click Google login button\n   - Verify OAuth flow redirects to Google\n   - Complete Google authentication\n   - Verify redirect back to app with session\n   - Check profile was auto-created in profiles table\n   - Verify session persists on page refresh\n   - Test logout functionality\n   - Verify middleware redirects unauthenticated users\n4. Check auth state with React DevTools\n5. Verify cookies are set correctly",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Supabase client utilities for browser and server-side usage",
            "description": "Implement infrastructure layer Supabase client configurations for browser-side and server-side contexts using @supabase/ssr package with proper cookie handling.",
            "dependencies": [],
            "details": "Create three files in src/infrastructure/supabase/:\n\n1. client.ts - Browser client for client components:\n   - Import createBrowserClient from @supabase/ssr\n   - Export createClient() function using NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY\n   - This client will be used in React client components\n\n2. server.ts - Server client for server components and API routes:\n   - Import createServerClient from @supabase/ssr\n   - Import cookies from next/headers\n   - Implement cookie handlers: get(name), set(name, value, options), remove(name, options)\n   - Export createClient() that uses cookieStore for session management\n   - This enables server-side authentication with proper cookie handling\n\n3. middleware.ts - Helper for Next.js middleware:\n   - Import createServerClient from @supabase/ssr\n   - Import NextResponse from next/server\n   - Export updateSession() function that refreshes auth session\n   - Handle request/response cookie manipulation for session persistence\n\nThese utilities form the foundation for all authentication operations across client and server contexts.\n<info added on 2025-12-19T00:44:48.947Z>\nBased on the user request confirming the completion of subtask 3.1, here's the update that should be appended:\n\nImplementation completed successfully. All three Supabase client utilities have been created in src/infrastructure/supabase/:\n\n- client.ts: Browser client using createBrowserClient from @supabase/ssr with NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY environment variables\n- server.ts: Server client using createServerClient with Next.js cookies() integration for session management via cookie handlers (get, set, remove)\n- middleware.ts: Next.js middleware helper with updateSession() function for auth session refresh and cookie persistence\n\nTypeScript type checking and ESLint validation both passed without errors. The infrastructure foundation is now ready for authentication operations across client and server contexts.\n</info added on 2025-12-19T00:44:48.947Z>",
            "status": "done",
            "testStrategy": "Verify by:\n1. Creating a test client component that calls createClient() from infrastructure/supabase/client.ts\n2. Creating a test server component that calls createClient() from infrastructure/supabase/server.ts\n3. Running TypeScript type check: pnpm tsc --noEmit\n4. Confirming environment variables are properly typed and accessed\n5. Testing that both clients can be instantiated without errors",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T00:44:25.083Z"
          },
          {
            "id": 2,
            "title": "Implement auth domain layer with entities, repository interface, and use cases",
            "description": "Create domain layer following DDD principles with User entity, AuthRepository interface, and use cases for sign-in, sign-out, and getting current user.",
            "dependencies": [
              1
            ],
            "details": "Create auth domain layer in src/features/auth/domain/:\n\n1. entities/user.ts - User domain entity:\n   ```typescript\n   export type User = {\n     id: string\n     email: string\n     username: string\n     avatarUrl: string | null\n   }\n   ```\n\n2. repositories/auth-repository.ts - Repository interface (dependency inversion):\n   ```typescript\n   export interface AuthRepository {\n     signInWithGoogle(): Promise<{ url: string }>\n     signOut(): Promise<void>\n     getCurrentUser(): Promise<User | null>\n     onAuthStateChange(callback: (user: User | null) => void): () => void\n   }\n   ```\n\n3. use-cases/sign-in-with-google.ts:\n   - Accept AuthRepository as dependency\n   - Call repository.signInWithGoogle()\n   - Return OAuth URL for redirection\n\n4. use-cases/sign-out.ts:\n   - Accept AuthRepository as dependency\n   - Call repository.signOut()\n   - Handle session cleanup\n\n5. use-cases/get-current-user.ts:\n   - Accept AuthRepository as dependency\n   - Call repository.getCurrentUser()\n   - Return User entity or null\n\nThis layer is framework-agnostic and contains pure business logic.\n<info added on 2025-12-19T01:58:29.045Z>\nI need to analyze the codebase to understand what was actually implemented and provide an accurate update to append to this subtask's details.Based on my analysis of the codebase, I can see that the auth domain layer has been successfully implemented with:\n\n1. **User entity** (src/features/auth/domain/entities/user.ts) - implemented as a class with validation and business methods\n2. **AuthRepository interface** (src/features/auth/domain/repositories/auth-repository.ts) - with all 4 required methods\n3. **Three use cases** with comprehensive tests:\n   - SignInWithGoogleUseCase (10 tests)\n   - SignOutUseCase (8 tests)\n   - GetCurrentUserUseCase (12 tests)\n4. **Total of 30 unit tests** across all use cases with thorough coverage including error handling\n\nNow I'll generate the update text:\n\nImplementation completed successfully. All components created following DDD/Clean Architecture principles:\n\n**Files Created:**\n- src/features/auth/domain/entities/user.ts - User entity class with validation, business methods (hasCompleteProfile, getDisplayName), and factory methods\n- src/features/auth/domain/repositories/auth-repository.ts - AuthRepository interface with 4 methods (signInWithGoogle, signOut, getCurrentUser, onAuthStateChange)\n- src/features/auth/domain/use-cases/sign-in-with-google.ts - SignInWithGoogleUseCase with OAuth URL validation\n- src/features/auth/domain/use-cases/sign-out.ts - SignOutUseCase with session cleanup\n- src/features/auth/domain/use-cases/get-current-user.ts - GetCurrentUserUseCase with authentication status\n- src/features/auth/domain/index.ts - Barrel export for clean API\n\n**Test Coverage:**\nCreated comprehensive unit tests (30 test cases total, 467 lines):\n- sign-in-with-google.test.ts: 10 tests (success cases, validation, error handling)\n- sign-out.test.ts: 8 tests (success cases, error handling, edge cases)\n- get-current-user.test.ts: 12 tests (authenticated/unauthenticated states, User entity integration, error handling)\n\nAll tests use mocked AuthRepository following dependency inversion principle. Tests cover success paths, error handling, edge cases, and integration with User entity methods.\n\n**Verification:**\n- TypeScript compilation: ✓ Passed (pnpm type-check)\n- Unit tests: ✓ All 30 tests passing (pnpm test)\n- Test coverage: 100% for domain layer\n- Architecture compliance: ✓ Framework-agnostic, pure business logic, proper dependency injection\n</info added on 2025-12-19T01:58:29.045Z>",
            "status": "done",
            "testStrategy": "Unit test with mocked repository:\n1. Mock AuthRepository implementation\n2. Test signInWithGoogle use case returns OAuth URL\n3. Test signOut use case calls repository method\n4. Test getCurrentUser returns User entity when authenticated\n5. Test getCurrentUser returns null when not authenticated\n6. Verify all use cases handle repository errors correctly\n7. Confirm TypeScript types are properly exported and used",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T01:57:25.017Z"
          },
          {
            "id": 3,
            "title": "Implement SupabaseAuthRepository in infrastructure layer",
            "description": "Create concrete implementation of AuthRepository interface using Supabase clients, handling OAuth flow, session management, and auth state changes.",
            "dependencies": [
              2
            ],
            "details": "Create src/features/auth/infrastructure/supabase-auth-repository.ts:\n\nImplement AuthRepository interface with Supabase-specific logic:\n\n1. signInWithGoogle():\n   - Use browser client createClient()\n   - Call supabase.auth.signInWithOAuth({ provider: 'google', options: { redirectTo: '/auth/callback' } })\n   - Return OAuth URL from response\n\n2. signOut():\n   - Use browser client\n   - Call supabase.auth.signOut()\n   - Clear local session state\n\n3. getCurrentUser():\n   - Use appropriate client (browser/server based on context)\n   - Call supabase.auth.getUser()\n   - Fetch profile data from profiles table using user.id\n   - Map Supabase user + profile to domain User entity\n   - Return User or null\n\n4. onAuthStateChange(callback):\n   - Use browser client\n   - Call supabase.auth.onAuthStateChange((event, session) => { ... })\n   - Map session to User entity\n   - Call callback with User or null\n   - Return unsubscribe function\n\nKey considerations:\n- Map between Supabase types and domain User entity\n- Handle errors gracefully\n- Join auth.users with profiles table for complete user data",
            "status": "pending",
            "testStrategy": "Integration tests with test Supabase instance:\n1. Test signInWithGoogle returns valid OAuth URL\n2. Test getCurrentUser returns null when not authenticated\n3. Test getCurrentUser returns User entity when authenticated\n4. Test signOut clears session\n5. Test onAuthStateChange fires callback on auth state changes\n6. Mock Supabase client for unit tests\n7. Verify error handling for network failures\n8. Test that profile data is correctly joined with auth data",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create auth presentation layer with provider, hooks, and login page",
            "description": "Implement React context provider for auth state, custom hooks for authentication operations, and login page UI using shadcn/ui components.",
            "dependencies": [
              3
            ],
            "details": "Create auth presentation layer:\n\n1. src/features/auth/presentation/providers/auth-provider.tsx:\n   - Wrap app with QueryClientProvider from TanStack Query\n   - Create AuthContext with current user state\n   - Use onAuthStateChange to sync auth state\n   - Provide loading state during initialization\n   - Export AuthProvider component\n\n2. src/features/auth/presentation/hooks/use-auth.ts:\n   - useContext hook to access AuthContext\n   - Return { user, isLoading, isAuthenticated }\n   - Export useAuth hook\n\n3. src/features/auth/presentation/hooks/use-require-auth.ts:\n   - Custom hook that redirects to /login if not authenticated\n   - Use useAuth and useRouter\n   - Show loading state while checking auth\n\n4. src/app/login/page.tsx:\n   - Install shadcn Button: npx shadcn add button\n   - Import Button from @/shared/ui/button\n   - Create centered layout with app title\n   - Add Google login button\n   - onClick calls signInWithGoogle() and redirects to OAuth URL\n   - Show loading state during OAuth initiation\n   - Redirect to chat if already authenticated\n\n5. Update src/app/layout.tsx:\n   - Wrap children with AuthProvider\n   - Import global styles\n\nDesign: Clean, centered card layout with prominent Google sign-in button.",
            "status": "pending",
            "testStrategy": "Component and integration tests:\n1. Test AuthProvider initializes with loading state\n2. Test useAuth returns correct user state\n3. Test useRequireAuth redirects unauthenticated users\n4. Test login page renders Google button\n5. Test button click triggers signInWithGoogle\n6. Test loading state displays during OAuth flow\n7. Manual test: Click button and verify Google OAuth screen appears\n8. Test authenticated users are redirected from /login to main app\n9. Verify AuthProvider re-renders on auth state changes",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement auth callback route, middleware, and logout functionality",
            "description": "Create OAuth callback handler to exchange code for session, implement Next.js middleware for session refresh and route protection, and add logout functionality to navigation.",
            "dependencies": [
              4
            ],
            "details": "Complete authentication flow:\n\n1. src/app/auth/callback/route.ts:\n   - Create GET route handler\n   - Extract code from URL searchParams\n   - Use server client createClient()\n   - Call supabase.auth.exchangeCodeForSession(code)\n   - Redirect to /chat on success\n   - Handle errors with redirect to /login?error=...\n\n2. src/middleware.ts:\n   - Import updateSession from infrastructure/supabase/middleware\n   - Export middleware function\n   - Call updateSession(request) to refresh auth session\n   - Check authentication status\n   - Redirect unauthenticated users to /login (except for /login and /auth/callback)\n   - Return response with updated cookies\n   - Export config matching all routes except _next/static, _next/image, favicon.ico\n\n3. Create header/navigation with logout:\n   - src/shared/components/header.tsx or src/app/components/header.tsx\n   - Show user avatar and username (use useAuth)\n   - Add logout button/dropdown\n   - onClick calls signOut() and redirects to /login\n   - Use shadcn DropdownMenu for user menu (npx shadcn add dropdown-menu)\n\n4. Integration:\n   - Add Header to main layout\n   - Test complete flow: login → callback → protected route → logout\n\nThis completes the authentication infrastructure with full OAuth flow and session management.",
            "status": "pending",
            "testStrategy": "End-to-end authentication flow testing:\n1. Start from /login, click Google sign-in\n2. Complete Google OAuth flow\n3. Verify redirect to /auth/callback\n4. Verify callback exchanges code for session\n5. Verify redirect to /chat with active session\n6. Refresh page and confirm session persists\n7. Test middleware: access protected route when logged out → redirect to /login\n8. Test logout: click logout button → session cleared → redirect to /login\n9. Verify cookies are set correctly (sb-access-token, sb-refresh-token)\n10. Test error handling: invalid OAuth code → error page\n11. Verify profile auto-creation trigger runs after first login\n12. Check middleware performance (should not slow down requests significantly)",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-19T01:57:25.017Z"
      },
      {
        "id": 4,
        "title": "Implement profile management feature with avatar upload",
        "description": "Create profile domain layer, repository implementation for profile CRUD operations, avatar upload to Supabase Storage, profile edit UI components, and integrate with shadcn/ui components.",
        "details": "1. Create profile domain layer:\n   src/features/profile/domain/entities/profile.ts\n   ```typescript\n   export type Profile = {\n     id: string\n     username: string\n     avatarUrl: string | null\n     createdAt: Date\n     updatedAt: Date\n   }\n   ```\n\n   src/features/profile/domain/repositories/profile-repository.ts (interface)\n   Methods: getProfile(userId), updateProfile(userId, data), uploadAvatar(userId, file)\n\n   src/features/profile/domain/use-cases/get-profile.ts\n   src/features/profile/domain/use-cases/update-profile.ts\n   src/features/profile/domain/use-cases/upload-avatar.ts\n\n2. Implement profile repository:\n   src/features/profile/infrastructure/supabase-profile-repository.ts\n   \n   Key implementations:\n   - getProfile: SELECT from profiles table\n   - updateProfile: UPDATE profiles with optimistic locking\n   - uploadAvatar: \n     * Generate file path: `{userId}/avatar.{ext}`\n     * Upload to avatars bucket\n     * Update profile.avatar_url with public URL\n     * Handle file size limits (max 2MB)\n\n3. Create profile presentation layer hooks:\n   src/features/profile/presentation/hooks/use-profile.ts\n   ```typescript\n   export function useProfile(userId: string) {\n     return useQuery({\n       queryKey: ['profile', userId],\n       queryFn: () => getProfile(userId)\n     })\n   }\n   ```\n\n   src/features/profile/presentation/hooks/use-update-profile.ts\n   ```typescript\n   export function useUpdateProfile() {\n     const queryClient = useQueryClient()\n     return useMutation({\n       mutationFn: updateProfile,\n       onSuccess: () => {\n         queryClient.invalidateQueries({ queryKey: ['profile'] })\n       }\n     })\n   }\n   ```\n\n   src/features/profile/presentation/hooks/use-upload-avatar.ts (similar pattern)\n\n4. Create shared UI components using shadcn:\n   src/shared/components/ui/avatar.tsx (npx shadcn add avatar)\n   src/shared/components/ui/input.tsx (npx shadcn add input)\n   src/shared/components/ui/button.tsx (npx shadcn add button)\n   src/shared/components/ui/form.tsx (npx shadcn add form)\n   \n5. Create profile-specific components:\n   src/features/profile/presentation/components/profile-avatar.tsx\n   - Displays avatar with fallback to initial\n   - Click to open file picker\n   - Shows upload progress\n\n   src/features/profile/presentation/components/profile-edit-form.tsx\n   - Form with username input\n   - Avatar upload component\n   - Save/Cancel buttons\n   - Form validation with zod\n\n6. Create profile edit page:\n   src/app/profile/edit/page.tsx\n   - Requires authentication (use useRequireAuth)\n   - Loads current user profile\n   - Renders ProfileEditForm\n   - Handles success/error states\n\n7. Create profile display component:\n   src/features/profile/presentation/components/profile-card.tsx\n   - Shows username and avatar\n   - Used in header/navigation\n   - Link to profile edit page\n\n8. Add profile link to header/navigation",
        "testStrategy": "Testing strategy:\n1. Unit tests:\n   - Use cases with mocked repositories\n   - Validation logic for username format\n   - Avatar file type/size validation\n2. Integration tests:\n   - Repository methods with test database\n   - File upload to Storage\n3. Component tests:\n   - ProfileAvatar renders correctly\n   - ProfileEditForm submission\n   - Form validation errors display\n4. Manual testing:\n   - Edit profile page loads current data\n   - Update username and save\n   - Upload avatar image (test various formats)\n   - Verify avatar displays in header\n   - Test avatar URL generation\n   - Check profile updates reflect in database\n   - Test file size limit enforcement\n5. Accessibility testing:\n   - Form labels and ARIA attributes\n   - Keyboard navigation\n   - Screen reader compatibility",
        "priority": "medium",
        "dependencies": [
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create profile domain layer with entities, repository interface, and use cases",
            "description": "Implement the profile domain layer following DDD principles with Profile entity, ProfileRepository interface, and use cases for getting, updating profile, and uploading avatar.",
            "dependencies": [],
            "details": "Create domain layer in src/features/profile/domain/:\n\n1. entities/profile.ts - Profile domain entity:\n```typescript\nexport type Profile = {\n  id: string\n  username: string\n  avatarUrl: string | null\n  createdAt: Date\n  updatedAt: Date\n}\n\nexport type UpdateProfileData = {\n  username?: string\n}\n```\n\n2. repositories/profile-repository.ts - Repository interface (dependency inversion):\n```typescript\nimport { Profile, UpdateProfileData } from '../entities/profile'\n\nexport interface ProfileRepository {\n  getProfile(userId: string): Promise<Profile | null>\n  updateProfile(userId: string, data: UpdateProfileData): Promise<Profile>\n  uploadAvatar(userId: string, file: File): Promise<string>\n}\n```\n\n3. use-cases/get-profile.ts:\n```typescript\nimport { ProfileRepository } from '../repositories/profile-repository'\nimport { Profile } from '../entities/profile'\n\nexport async function getProfile(\n  repository: ProfileRepository,\n  userId: string\n): Promise<Profile | null> {\n  return repository.getProfile(userId)\n}\n```\n\n4. use-cases/update-profile.ts:\n```typescript\nimport { ProfileRepository } from '../repositories/profile-repository'\nimport { Profile, UpdateProfileData } from '../entities/profile'\n\nexport async function updateProfile(\n  repository: ProfileRepository,\n  userId: string,\n  data: UpdateProfileData\n): Promise<Profile> {\n  // Validation: username must be 3-20 characters, alphanumeric + underscores\n  if (data.username) {\n    if (data.username.length < 3 || data.username.length > 20) {\n      throw new Error('Username must be between 3 and 20 characters')\n    }\n    if (!/^[a-zA-Z0-9_]+$/.test(data.username)) {\n      throw new Error('Username can only contain letters, numbers, and underscores')\n    }\n  }\n  \n  return repository.updateProfile(userId, data)\n}\n```\n\n5. use-cases/upload-avatar.ts:\n```typescript\nimport { ProfileRepository } from '../repositories/profile-repository'\n\nconst MAX_FILE_SIZE = 2 * 1024 * 1024 // 2MB\nconst ALLOWED_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'image/webp']\n\nexport async function uploadAvatar(\n  repository: ProfileRepository,\n  userId: string,\n  file: File\n): Promise<string> {\n  // Validate file size\n  if (file.size > MAX_FILE_SIZE) {\n    throw new Error('File size must be less than 2MB')\n  }\n  \n  // Validate file type\n  if (!ALLOWED_TYPES.includes(file.type)) {\n    throw new Error('File must be an image (JPEG, PNG, GIF, or WebP)')\n  }\n  \n  return repository.uploadAvatar(userId, file)\n}\n```\n\nThis layer is framework-agnostic and contains pure business logic with validation rules.",
            "status": "pending",
            "testStrategy": "Unit tests with mocked ProfileRepository:\n1. Test getProfile returns Profile entity when user exists\n2. Test getProfile returns null when user doesn't exist\n3. Test updateProfile validates username length (min 3, max 20 characters)\n4. Test updateProfile validates username format (alphanumeric + underscores only)\n5. Test updateProfile throws error for invalid username\n6. Test uploadAvatar validates file size (max 2MB)\n7. Test uploadAvatar validates file type (JPEG, PNG, GIF, WebP only)\n8. Test uploadAvatar throws error for oversized files\n9. Test uploadAvatar throws error for invalid file types\n10. Verify all use cases properly call repository methods",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement SupabaseProfileRepository in infrastructure layer with CRUD and storage operations",
            "description": "Create concrete implementation of ProfileRepository interface using Supabase client for database operations and Storage API for avatar uploads with proper error handling and RLS compliance.",
            "dependencies": [
              1
            ],
            "details": "Create src/features/profile/infrastructure/supabase-profile-repository.ts:\n\nImplement ProfileRepository interface with Supabase-specific logic:\n\n```typescript\nimport { createClient as createBrowserClient } from '@/infrastructure/supabase/client'\nimport { createClient as createServerClient } from '@/infrastructure/supabase/server'\nimport { ProfileRepository } from '../domain/repositories/profile-repository'\nimport { Profile, UpdateProfileData } from '../domain/entities/profile'\n\nexport class SupabaseProfileRepository implements ProfileRepository {\n  async getProfile(userId: string): Promise<Profile | null> {\n    const supabase = createBrowserClient() // or createServerClient() depending on context\n    \n    const { data, error } = await supabase\n      .from('profiles')\n      .select('id, username, avatar_url, created_at, updated_at')\n      .eq('id', userId)\n      .single()\n    \n    if (error) {\n      if (error.code === 'PGRST116') return null // Not found\n      throw new Error(`Failed to fetch profile: ${error.message}`)\n    }\n    \n    return {\n      id: data.id,\n      username: data.username,\n      avatarUrl: data.avatar_url,\n      createdAt: new Date(data.created_at),\n      updatedAt: new Date(data.updated_at)\n    }\n  }\n\n  async updateProfile(userId: string, updateData: UpdateProfileData): Promise<Profile> {\n    const supabase = createBrowserClient()\n    \n    const { data, error } = await supabase\n      .from('profiles')\n      .update({\n        username: updateData.username,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', userId)\n      .select()\n      .single()\n    \n    if (error) {\n      throw new Error(`Failed to update profile: ${error.message}`)\n    }\n    \n    return {\n      id: data.id,\n      username: data.username,\n      avatarUrl: data.avatar_url,\n      createdAt: new Date(data.created_at),\n      updatedAt: new Date(data.updated_at)\n    }\n  }\n\n  async uploadAvatar(userId: string, file: File): Promise<string> {\n    const supabase = createBrowserClient()\n    \n    // Generate file path: {userId}/avatar.{ext}\n    const fileExt = file.name.split('.').pop()\n    const filePath = `${userId}/avatar.${fileExt}`\n    \n    // Upload to avatars bucket (replaces existing file if present)\n    const { error: uploadError } = await supabase.storage\n      .from('avatars')\n      .upload(filePath, file, {\n        upsert: true,\n        contentType: file.type\n      })\n    \n    if (uploadError) {\n      throw new Error(`Failed to upload avatar: ${uploadError.message}`)\n    }\n    \n    // Get public URL\n    const { data: { publicUrl } } = supabase.storage\n      .from('avatars')\n      .getPublicUrl(filePath)\n    \n    // Update profile.avatar_url\n    const { error: updateError } = await supabase\n      .from('profiles')\n      .update({ avatar_url: publicUrl })\n      .eq('id', userId)\n    \n    if (updateError) {\n      throw new Error(`Failed to update profile avatar URL: ${updateError.message}`)\n    }\n    \n    return publicUrl\n  }\n}\n\n// Export singleton instance\nexport const profileRepository = new SupabaseProfileRepository()\n```\n\nKey implementation details:\n- Map between Supabase snake_case and domain camelCase\n- Handle RLS errors gracefully\n- Use upsert for avatar uploads to replace existing files\n- Return public URL from Storage API\n- Update profile record with new avatar URL atomically",
            "status": "pending",
            "testStrategy": "Integration tests with test Supabase instance:\n1. Test getProfile returns correct Profile entity for existing user\n2. Test getProfile returns null for non-existent user\n3. Test getProfile handles database errors gracefully\n4. Test updateProfile successfully updates username\n5. Test updateProfile respects RLS policies (can only update own profile)\n6. Test updateProfile handles concurrent updates (optimistic locking)\n7. Test uploadAvatar uploads file to correct path ({userId}/avatar.ext)\n8. Test uploadAvatar overwrites existing avatar file (upsert: true)\n9. Test uploadAvatar returns valid public URL\n10. Test uploadAvatar updates profile.avatar_url in database\n11. Test uploadAvatar handles Storage errors (quota, permissions)\n12. Mock Supabase client for unit tests to verify method calls\n13. Verify proper error messages are thrown for all failure cases",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create profile presentation layer hooks using TanStack Query for data fetching and mutations",
            "description": "Implement React hooks for profile operations with TanStack Query for caching, optimistic updates, and automatic refetching. Include hooks for fetching profile, updating profile, and uploading avatars.",
            "dependencies": [
              2
            ],
            "details": "Create presentation hooks in src/features/profile/presentation/hooks/:\n\n1. use-profile.ts - Query hook for fetching profile:\n```typescript\nimport { useQuery } from '@tanstack/react-query'\nimport { profileRepository } from '../../infrastructure/supabase-profile-repository'\nimport { getProfile } from '../../domain/use-cases/get-profile'\n\nexport function useProfile(userId: string | null) {\n  return useQuery({\n    queryKey: ['profile', userId],\n    queryFn: () => {\n      if (!userId) throw new Error('User ID is required')\n      return getProfile(profileRepository, userId)\n    },\n    enabled: !!userId,\n    staleTime: 1000 * 60 * 5, // 5 minutes\n  })\n}\n```\n\n2. use-update-profile.ts - Mutation hook for updating profile:\n```typescript\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { profileRepository } from '../../infrastructure/supabase-profile-repository'\nimport { updateProfile } from '../../domain/use-cases/update-profile'\nimport { UpdateProfileData } from '../../domain/entities/profile'\n\ninterface UpdateProfileParams {\n  userId: string\n  data: UpdateProfileData\n}\n\nexport function useUpdateProfile() {\n  const queryClient = useQueryClient()\n  \n  return useMutation({\n    mutationFn: ({ userId, data }: UpdateProfileParams) => \n      updateProfile(profileRepository, userId, data),\n    onSuccess: (updatedProfile) => {\n      // Update cache with new profile data\n      queryClient.setQueryData(['profile', updatedProfile.id], updatedProfile)\n      \n      // Invalidate to trigger refetch\n      queryClient.invalidateQueries({ queryKey: ['profile'] })\n    },\n    onError: (error) => {\n      console.error('Failed to update profile:', error)\n    }\n  })\n}\n```\n\n3. use-upload-avatar.ts - Mutation hook for uploading avatar:\n```typescript\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { profileRepository } from '../../infrastructure/supabase-profile-repository'\nimport { uploadAvatar } from '../../domain/use-cases/upload-avatar'\n\ninterface UploadAvatarParams {\n  userId: string\n  file: File\n}\n\nexport function useUploadAvatar() {\n  const queryClient = useQueryClient()\n  \n  return useMutation({\n    mutationFn: ({ userId, file }: UploadAvatarParams) => \n      uploadAvatar(profileRepository, userId, file),\n    onSuccess: (avatarUrl, { userId }) => {\n      // Optimistically update profile cache with new avatar URL\n      queryClient.setQueryData(['profile', userId], (oldData: any) => {\n        if (!oldData) return oldData\n        return {\n          ...oldData,\n          avatarUrl,\n          updatedAt: new Date()\n        }\n      })\n      \n      // Invalidate to trigger refetch and get updated data\n      queryClient.invalidateQueries({ queryKey: ['profile', userId] })\n    },\n    onError: (error) => {\n      console.error('Failed to upload avatar:', error)\n    }\n  })\n}\n```\n\nThese hooks provide:\n- Automatic caching and refetching\n- Loading and error states\n- Optimistic updates for better UX\n- Query invalidation to keep data fresh\n- Type-safe API",
            "status": "pending",
            "testStrategy": "Component tests using React Testing Library and renderHook:\n1. Test useProfile fetches profile data on mount\n2. Test useProfile returns loading state initially\n3. Test useProfile returns profile data on success\n4. Test useProfile returns error state on failure\n5. Test useProfile is disabled when userId is null\n6. Test useProfile caches data for 5 minutes (staleTime)\n7. Test useUpdateProfile successfully updates profile\n8. Test useUpdateProfile updates cache optimistically\n9. Test useUpdateProfile invalidates queries on success\n10. Test useUpdateProfile handles validation errors from use case\n11. Test useUploadAvatar uploads file and returns URL\n12. Test useUploadAvatar updates cache with new avatar URL\n13. Test useUploadAvatar invalidates profile query on success\n14. Test useUploadAvatar handles file size/type validation errors\n15. Mock repository to verify use case calls\n16. Test concurrent mutations don't cause race conditions\n17. Verify proper TypeScript types for all hooks",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Build profile UI components with shadcn/ui for avatar display and profile editing form",
            "description": "Create reusable profile components including ProfileAvatar for displaying user avatars with upload functionality, and ProfileEditForm with username input, avatar upload, and form validation using zod and shadcn/ui components.",
            "dependencies": [
              3
            ],
            "details": "Install required shadcn/ui components:\n```bash\nnpx shadcn add avatar\nnpx shadcn add input\nnpx shadcn add button\nnpx shadcn add form\nnpx shadcn add label\nnpx shadcn add toast\n```\n\nInstall form dependencies:\n```bash\npnpm add react-hook-form zod @hookform/resolvers\n```\n\n1. Create src/features/profile/presentation/components/profile-avatar.tsx:\n```typescript\nimport { Avatar, AvatarFallback, AvatarImage } from '@/shared/ui/avatar'\nimport { Button } from '@/shared/ui/button'\nimport { useUploadAvatar } from '../hooks/use-upload-avatar'\nimport { useRef } from 'react'\nimport { Loader2 } from 'lucide-react'\n\ninterface ProfileAvatarProps {\n  userId: string\n  avatarUrl: string | null\n  username: string\n  editable?: boolean\n}\n\nexport function ProfileAvatar({ userId, avatarUrl, username, editable = false }: ProfileAvatarProps) {\n  const fileInputRef = useRef<HTMLInputElement>(null)\n  const { mutate: uploadAvatar, isPending } = useUploadAvatar()\n  \n  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const file = e.target.files?.[0]\n    if (file) {\n      uploadAvatar({ userId, file })\n    }\n  }\n  \n  const handleClick = () => {\n    if (editable && fileInputRef.current) {\n      fileInputRef.current.click()\n    }\n  }\n  \n  const initial = username.charAt(0).toUpperCase()\n  \n  return (\n    <div className=\"relative\">\n      <Avatar \n        className={`h-20 w-20 ${editable ? 'cursor-pointer' : ''}`}\n        onClick={handleClick}\n      >\n        <AvatarImage src={avatarUrl || undefined} alt={username} />\n        <AvatarFallback>{initial}</AvatarFallback>\n      </Avatar>\n      \n      {isPending && (\n        <div className=\"absolute inset-0 flex items-center justify-center bg-black/50 rounded-full\">\n          <Loader2 className=\"h-6 w-6 animate-spin text-white\" />\n        </div>\n      )}\n      \n      {editable && (\n        <input\n          ref={fileInputRef}\n          type=\"file\"\n          accept=\"image/jpeg,image/png,image/gif,image/webp\"\n          className=\"hidden\"\n          onChange={handleFileChange}\n        />\n      )}\n    </div>\n  )\n}\n```\n\n2. Create src/features/profile/presentation/components/profile-edit-form.tsx:\n```typescript\nimport { useForm } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { z } from 'zod'\nimport { Button } from '@/shared/ui/button'\nimport { Input } from '@/shared/ui/input'\nimport { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/shared/ui/form'\nimport { useUpdateProfile } from '../hooks/use-update-profile'\nimport { ProfileAvatar } from './profile-avatar'\nimport { useToast } from '@/shared/ui/use-toast'\nimport { Profile } from '../../domain/entities/profile'\n\nconst formSchema = z.object({\n  username: z.string()\n    .min(3, 'Username must be at least 3 characters')\n    .max(20, 'Username must be at most 20 characters')\n    .regex(/^[a-zA-Z0-9_]+$/, 'Username can only contain letters, numbers, and underscores')\n})\n\ntype FormData = z.infer<typeof formSchema>\n\ninterface ProfileEditFormProps {\n  profile: Profile\n  onSuccess?: () => void\n}\n\nexport function ProfileEditForm({ profile, onSuccess }: ProfileEditFormProps) {\n  const { toast } = useToast()\n  const { mutate: updateProfile, isPending } = useUpdateProfile()\n  \n  const form = useForm<FormData>({\n    resolver: zodResolver(formSchema),\n    defaultValues: {\n      username: profile.username\n    }\n  })\n  \n  const onSubmit = (data: FormData) => {\n    updateProfile(\n      { userId: profile.id, data },\n      {\n        onSuccess: () => {\n          toast({\n            title: 'Profile updated',\n            description: 'Your profile has been updated successfully.'\n          })\n          onSuccess?.()\n        },\n        onError: (error) => {\n          toast({\n            title: 'Error',\n            description: error.message,\n            variant: 'destructive'\n          })\n        }\n      }\n    )\n  }\n  \n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex justify-center\">\n        <ProfileAvatar\n          userId={profile.id}\n          avatarUrl={profile.avatarUrl}\n          username={profile.username}\n          editable\n        />\n      </div>\n      \n      <Form {...form}>\n        <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-4\">\n          <FormField\n            control={form.control}\n            name=\"username\"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel>Username</FormLabel>\n                <FormControl>\n                  <Input {...field} />\n                </FormControl>\n                <FormMessage />\n              </FormItem>\n            )}\n          />\n          \n          <div className=\"flex gap-2\">\n            <Button type=\"submit\" disabled={isPending}>\n              {isPending ? 'Saving...' : 'Save changes'}\n            </Button>\n            <Button type=\"button\" variant=\"outline\" onClick={() => form.reset()}>\n              Cancel\n            </Button>\n          </div>\n        </form>\n      </Form>\n    </div>\n  )\n}\n```\n\n3. Create src/features/profile/presentation/components/profile-card.tsx:\n```typescript\nimport { ProfileAvatar } from './profile-avatar'\nimport { Profile } from '../../domain/entities/profile'\nimport Link from 'next/link'\n\ninterface ProfileCardProps {\n  profile: Profile\n  showEditLink?: boolean\n}\n\nexport function ProfileCard({ profile, showEditLink = false }: ProfileCardProps) {\n  return (\n    <div className=\"flex items-center gap-3\">\n      <ProfileAvatar\n        userId={profile.id}\n        avatarUrl={profile.avatarUrl}\n        username={profile.username}\n      />\n      <div>\n        <p className=\"font-medium\">{profile.username}</p>\n        {showEditLink && (\n          <Link href=\"/profile/edit\" className=\"text-sm text-muted-foreground hover:underline\">\n            Edit profile\n          </Link>\n        )}\n      </div>\n    </div>\n  )\n}\n```\n\nComponents include:\n- Avatar with fallback to username initial\n- Click-to-upload functionality with file input\n- Upload progress indicator\n- Form validation with zod\n- Toast notifications for success/error\n- Responsive design with Tailwind CSS",
            "status": "pending",
            "testStrategy": "Component tests with React Testing Library:\n1. Test ProfileAvatar renders avatar image when avatarUrl is provided\n2. Test ProfileAvatar shows fallback initial when no avatarUrl\n3. Test ProfileAvatar opens file picker on click when editable\n4. Test ProfileAvatar uploads file when selected\n5. Test ProfileAvatar shows loading spinner during upload\n6. Test ProfileAvatar handles upload errors with toast\n7. Test ProfileEditForm renders with correct initial values\n8. Test ProfileEditForm validates username (min 3, max 20 chars)\n9. Test ProfileEditForm validates username format (alphanumeric + underscore)\n10. Test ProfileEditForm shows validation errors\n11. Test ProfileEditForm submits correct data on valid input\n12. Test ProfileEditForm shows success toast on successful update\n13. Test ProfileEditForm shows error toast on update failure\n14. Test ProfileEditForm disables submit button during submission\n15. Test ProfileEditForm reset button restores initial values\n16. Test ProfileCard renders profile information correctly\n17. Test ProfileCard shows edit link when showEditLink is true\n18. Verify accessibility: form labels, ARIA attributes, keyboard navigation\n19. Test responsive behavior on different screen sizes",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create profile edit page and integrate profile display in app header/navigation",
            "description": "Implement /profile/edit page with authentication guard, profile data loading, and ProfileEditForm integration. Add ProfileCard to app header showing current user with link to edit page.",
            "dependencies": [
              4
            ],
            "details": "1. Create src/app/profile/edit/page.tsx:\n```typescript\n'use client'\n\nimport { useAuth } from '@/features/auth/presentation/hooks/use-auth'\nimport { useRequireAuth } from '@/features/auth/presentation/hooks/use-require-auth'\nimport { useProfile } from '@/features/profile/presentation/hooks/use-profile'\nimport { ProfileEditForm } from '@/features/profile/presentation/components/profile-edit-form'\nimport { Loader2 } from 'lucide-react'\nimport { useRouter } from 'next/navigation'\n\nexport default function ProfileEditPage() {\n  // Redirect to login if not authenticated\n  useRequireAuth()\n  \n  const router = useRouter()\n  const { user } = useAuth()\n  const { data: profile, isLoading, error } = useProfile(user?.id || null)\n  \n  if (isLoading) {\n    return (\n      <div className=\"flex min-h-screen items-center justify-center\">\n        <Loader2 className=\"h-8 w-8 animate-spin\" />\n      </div>\n    )\n  }\n  \n  if (error) {\n    return (\n      <div className=\"flex min-h-screen items-center justify-center\">\n        <div className=\"text-center\">\n          <h1 className=\"text-2xl font-bold mb-2\">Error loading profile</h1>\n          <p className=\"text-muted-foreground\">{error.message}</p>\n        </div>\n      </div>\n    )\n  }\n  \n  if (!profile) {\n    return (\n      <div className=\"flex min-h-screen items-center justify-center\">\n        <div className=\"text-center\">\n          <h1 className=\"text-2xl font-bold\">Profile not found</h1>\n        </div>\n      </div>\n    )\n  }\n  \n  return (\n    <div className=\"container max-w-2xl py-8\">\n      <h1 className=\"text-3xl font-bold mb-6\">Edit Profile</h1>\n      <div className=\"bg-card rounded-lg border p-6\">\n        <ProfileEditForm \n          profile={profile}\n          onSuccess={() => router.push('/chat')}\n        />\n      </div>\n    </div>\n  )\n}\n```\n\n2. Update or create src/app/components/header.tsx (or src/shared/components/header.tsx):\n```typescript\n'use client'\n\nimport { useAuth } from '@/features/auth/presentation/hooks/use-auth'\nimport { useProfile } from '@/features/profile/presentation/hooks/use-profile'\nimport { ProfileCard } from '@/features/profile/presentation/components/profile-card'\nimport { Button } from '@/shared/ui/button'\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuLabel,\n  DropdownMenuSeparator,\n  DropdownMenuTrigger,\n} from '@/shared/ui/dropdown-menu'\nimport { useRouter } from 'next/navigation'\nimport { profileRepository } from '@/features/profile/infrastructure/supabase-profile-repository'\n\nexport function Header() {\n  const router = useRouter()\n  const { user, isAuthenticated } = useAuth()\n  const { data: profile } = useProfile(user?.id || null)\n  \n  const handleLogout = async () => {\n    // Call signOut from auth repository\n    // Redirect to /login\n    router.push('/login')\n  }\n  \n  if (!isAuthenticated || !profile) {\n    return null\n  }\n  \n  return (\n    <header className=\"border-b\">\n      <div className=\"container flex h-16 items-center justify-between\">\n        <h1 className=\"text-xl font-bold\">Chat App</h1>\n        \n        <DropdownMenu>\n          <DropdownMenuTrigger asChild>\n            <Button variant=\"ghost\" className=\"h-auto p-2\">\n              <ProfileCard profile={profile} />\n            </Button>\n          </DropdownMenuTrigger>\n          <DropdownMenuContent align=\"end\">\n            <DropdownMenuLabel>My Account</DropdownMenuLabel>\n            <DropdownMenuSeparator />\n            <DropdownMenuItem onClick={() => router.push('/profile/edit')}>\n              Edit Profile\n            </DropdownMenuItem>\n            <DropdownMenuItem onClick={handleLogout}>\n              Logout\n            </DropdownMenuItem>\n          </DropdownMenuContent>\n        </DropdownMenu>\n      </div>\n    </header>\n  )\n}\n```\n\n3. Install required shadcn component:\n```bash\nnpx shadcn add dropdown-menu\n```\n\n4. Update src/app/layout.tsx to include Header:\n```typescript\nimport { Header } from './components/header'\nimport { AuthProvider } from '@/features/auth/presentation/providers/auth-provider'\nimport { Toaster } from '@/shared/ui/toaster'\nimport './globals.css'\n\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <AuthProvider>\n          <Header />\n          <main>{children}</main>\n          <Toaster />\n        </AuthProvider>\n      </body>\n    </html>\n  )\n}\n```\n\n5. Create src/shared/ui/use-toast.ts hook:\n```bash\nnpx shadcn add toast\n```\n\nIntegration points:\n- Profile edit page requires authentication\n- Header shows current user profile\n- Dropdown menu for profile actions\n- Seamless navigation between chat and profile edit\n- Toast notifications for feedback",
            "status": "pending",
            "testStrategy": "Integration and E2E testing:\n1. Test /profile/edit page redirects to /login when not authenticated\n2. Test /profile/edit page shows loading state while fetching profile\n3. Test /profile/edit page renders ProfileEditForm with current profile data\n4. Test /profile/edit page handles profile fetch errors gracefully\n5. Test /profile/edit page redirects to /chat after successful update\n6. Test Header renders with current user profile\n7. Test Header dropdown menu shows 'Edit Profile' and 'Logout' options\n8. Test Header 'Edit Profile' click navigates to /profile/edit\n9. Test Header 'Logout' click signs out and redirects to /login\n10. Test Header does not render when user is not authenticated\n11. Test complete user flow:\n    - Login → View header with profile → Click edit → Update username → Save → See updated name in header\n12. Test avatar upload flow:\n    - Edit profile → Click avatar → Select image → Upload → See new avatar in header\n13. Verify responsive behavior on mobile/tablet/desktop\n14. Test accessibility: keyboard navigation through dropdown menu\n15. Test error handling: network errors, validation errors\n16. Verify toast notifications appear for all user actions\n17. Test that profile updates are reflected immediately in all components (cache invalidation)",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement real-time chat feature with message CRUD and subscriptions",
        "description": "Create chat domain layer with message entities, implement repository with Supabase real-time subscriptions, build chat UI with message list and input form, handle optimistic updates, and display user avatars/names.",
        "details": "1. Create chat domain layer:\n   src/features/chat/domain/entities/message.ts\n   ```typescript\n   export type Message = {\n     id: string\n     userId: string\n     content: string\n     createdAt: Date\n     author: {\n       username: string\n       avatarUrl: string | null\n     }\n   }\n   ```\n\n   src/features/chat/domain/repositories/message-repository.ts (interface)\n   Methods: getMessages(), sendMessage(content), deleteMessage(id), subscribeToMessages(callback)\n\n   src/features/chat/domain/use-cases/get-messages.ts\n   src/features/chat/domain/use-cases/send-message.ts\n   src/features/chat/domain/use-cases/delete-message.ts\n   src/features/chat/domain/use-cases/subscribe-to-messages.ts\n\n2. Implement message repository:\n   src/features/chat/infrastructure/supabase-message-repository.ts\n   \n   Key implementations:\n   - getMessages: \n     ```sql\n     SELECT m.*, p.username, p.avatar_url\n     FROM messages m\n     JOIN profiles p ON m.user_id = p.id\n     ORDER BY m.created_at DESC\n     LIMIT 100\n     ```\n   - sendMessage: INSERT with user_id from auth\n   - deleteMessage: DELETE WHERE id = ? AND user_id = auth.uid()\n   - subscribeToMessages:\n     ```typescript\n     supabase\n       .channel('messages')\n       .on('postgres_changes', {\n         event: '*',\n         schema: 'public',\n         table: 'messages'\n       }, handleChange)\n       .subscribe()\n     ```\n\n3. Create presentation hooks:\n   src/features/chat/presentation/hooks/use-messages.ts\n   ```typescript\n   export function useMessages() {\n     const queryClient = useQueryClient()\n     \n     // Query for initial messages\n     const query = useQuery({\n       queryKey: ['messages'],\n       queryFn: getMessages\n     })\n\n     // Subscribe to real-time updates\n     useEffect(() => {\n       const subscription = subscribeToMessages((payload) => {\n         queryClient.invalidateQueries({ queryKey: ['messages'] })\n       })\n       return () => subscription.unsubscribe()\n     }, [])\n\n     return query\n   }\n   ```\n\n   src/features/chat/presentation/hooks/use-send-message.ts\n   ```typescript\n   export function useSendMessage() {\n     const queryClient = useQueryClient()\n     return useMutation({\n       mutationFn: sendMessage,\n       onMutate: async (content) => {\n         // Optimistic update\n         await queryClient.cancelQueries({ queryKey: ['messages'] })\n         const previous = queryClient.getQueryData(['messages'])\n         queryClient.setQueryData(['messages'], (old) => [\n           ...old,\n           { id: 'temp', content, createdAt: new Date(), /* ... */ }\n         ])\n         return { previous }\n       },\n       onError: (err, variables, context) => {\n         queryClient.setQueryData(['messages'], context.previous)\n       },\n       onSuccess: () => {\n         queryClient.invalidateQueries({ queryKey: ['messages'] })\n       }\n     })\n   }\n   ```\n\n   src/features/chat/presentation/hooks/use-delete-message.ts (similar pattern)\n\n4. Create chat UI components:\n   Install shadcn components:\n   npx shadcn add textarea\n   npx shadcn add scroll-area\n   npx shadcn add dropdown-menu\n\n   src/features/chat/presentation/components/message-item.tsx\n   - Avatar (from ProfileAvatar component)\n   - Username and timestamp\n   - Message content\n   - Delete button (only for own messages)\n   - Styling for own vs others' messages\n\n   src/features/chat/presentation/components/message-list.tsx\n   - ScrollArea with auto-scroll to bottom\n   - Maps messages to MessageItem\n   - Loading/empty states\n   - Virtualization for performance (optional)\n\n   src/features/chat/presentation/components/message-input.tsx\n   - Textarea for message content\n   - Send button (disabled when empty)\n   - Enter key to send (Shift+Enter for new line)\n   - Character limit indicator\n   - Loading state during send\n\n5. Create chat page:\n   src/app/chat/page.tsx or src/app/page.tsx (as main page)\n   - Layout with header (profile, logout)\n   - MessageList component\n   - MessageInput component\n   - Real-time connection indicator\n\n6. Add proper error handling:\n   - Network errors\n   - Permission errors (RLS violations)\n   - Connection loss/recovery\n   - Toast notifications for errors (npx shadcn add toast)\n\n7. Implement message formatting:\n   - Auto-link URLs\n   - Preserve line breaks\n   - XSS protection (sanitize content)\n\n8. Add date separators in message list",
        "testStrategy": "Comprehensive testing:\n1. Unit tests:\n   - Use cases with mocked repository\n   - Message content validation\n   - XSS sanitization\n2. Integration tests:\n   - Message CRUD operations\n   - Real-time subscription updates\n   - Multi-user message flow\n3. Component tests:\n   - MessageItem renders correctly\n   - MessageInput validation\n   - Delete button only shows for own messages\n   - Auto-scroll behavior\n4. Real-time testing:\n   - Open app in two browser windows\n   - Send message in window 1\n   - Verify appears in window 2 immediately\n   - Test message deletion propagation\n   - Test connection recovery after network interruption\n5. Manual testing:\n   - Send various message types (short, long, multi-line)\n   - Test Enter/Shift+Enter behavior\n   - Verify timestamps display correctly\n   - Check avatar and username display\n   - Test delete message functionality\n   - Verify RLS policies prevent unauthorized deletes\n   - Test with 10+ concurrent users\n6. Performance testing:\n   - Load 100+ messages\n   - Check scroll performance\n   - Monitor memory usage with subscriptions",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create chat domain layer with entities, repository interface, and use cases",
            "description": "Implement the chat domain layer following DDD principles with Message entity, MessageRepository interface, and use cases for getting, sending, deleting messages, and subscribing to real-time updates.",
            "dependencies": [],
            "details": "Create domain layer in src/features/chat/domain/:\n\n1. entities/message.ts - Message domain entity:\n```typescript\nexport type Message = {\n  id: string\n  userId: string\n  content: string\n  createdAt: Date\n  author: {\n    username: string\n    avatarUrl: string | null\n  }\n}\n```\n\n2. repositories/message-repository.ts - Repository interface (dependency inversion):\n```typescript\nimport { Message } from '../entities/message'\n\nexport interface MessageRepository {\n  getMessages(): Promise<Message[]>\n  sendMessage(content: string): Promise<Message>\n  deleteMessage(id: string): Promise<void>\n  subscribeToMessages(callback: (message: Message) => void): { unsubscribe: () => void }\n}\n```\n\n3. use-cases/get-messages.ts:\n```typescript\nimport { MessageRepository } from '../repositories/message-repository'\nimport { Message } from '../entities/message'\n\nexport async function getMessages(\n  repository: MessageRepository\n): Promise<Message[]> {\n  return repository.getMessages()\n}\n```\n\n4. use-cases/send-message.ts:\n```typescript\nimport { MessageRepository } from '../repositories/message-repository'\nimport { Message } from '../entities/message'\n\nconst MAX_MESSAGE_LENGTH = 2000\n\nexport async function sendMessage(\n  repository: MessageRepository,\n  content: string\n): Promise<Message> {\n  // Validation: message must not be empty\n  const trimmedContent = content.trim()\n  if (!trimmedContent) {\n    throw new Error('Message cannot be empty')\n  }\n  \n  // Validation: message length limit\n  if (trimmedContent.length > MAX_MESSAGE_LENGTH) {\n    throw new Error(`Message must be less than ${MAX_MESSAGE_LENGTH} characters`)\n  }\n  \n  // XSS protection: sanitize content (basic HTML escape)\n  const sanitizedContent = trimmedContent\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#x27;')\n  \n  return repository.sendMessage(sanitizedContent)\n}\n```\n\n5. use-cases/delete-message.ts:\n```typescript\nimport { MessageRepository } from '../repositories/message-repository'\n\nexport async function deleteMessage(\n  repository: MessageRepository,\n  messageId: string\n): Promise<void> {\n  if (!messageId) {\n    throw new Error('Message ID is required')\n  }\n  \n  return repository.deleteMessage(messageId)\n}\n```\n\n6. use-cases/subscribe-to-messages.ts:\n```typescript\nimport { MessageRepository } from '../repositories/message-repository'\nimport { Message } from '../entities/message'\n\nexport function subscribeToMessages(\n  repository: MessageRepository,\n  callback: (message: Message) => void\n): { unsubscribe: () => void } {\n  return repository.subscribeToMessages(callback)\n}\n```\n\nThis layer is framework-agnostic and contains pure business logic with validation and sanitization rules.",
            "status": "pending",
            "testStrategy": "Unit tests with mocked MessageRepository:\n1. Test getMessages returns array of Message entities\n2. Test sendMessage validates non-empty content\n3. Test sendMessage validates message length (max 2000 characters)\n4. Test sendMessage sanitizes HTML/XSS content (< > & \" ')\n5. Test sendMessage trims whitespace\n6. Test sendMessage throws error for empty/whitespace-only messages\n7. Test sendMessage throws error for messages exceeding length limit\n8. Test deleteMessage validates messageId is provided\n9. Test deleteMessage throws error for empty messageId\n10. Test subscribeToMessages returns unsubscribe function\n11. Verify all use cases properly call repository methods\n12. Test sanitization preserves line breaks and safe characters",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement SupabaseMessageRepository with real-time subscriptions and CRUD operations",
            "description": "Create concrete implementation of MessageRepository interface using Supabase client for database operations with JOIN to profiles table, and Supabase Realtime for message subscriptions following RLS policies.",
            "dependencies": [
              1
            ],
            "details": "Create src/features/chat/infrastructure/supabase-message-repository.ts:\n\nImplement MessageRepository interface with Supabase-specific logic:\n\n```typescript\nimport { createClient as createBrowserClient } from '@/infrastructure/supabase/client'\nimport { createClient as createServerClient } from '@/infrastructure/supabase/server'\nimport { MessageRepository } from '../domain/repositories/message-repository'\nimport { Message } from '../domain/entities/message'\nimport { RealtimeChannel } from '@supabase/supabase-js'\n\nexport class SupabaseMessageRepository implements MessageRepository {\n  async getMessages(): Promise<Message[]> {\n    const supabase = createBrowserClient()\n    \n    // JOIN messages with profiles to get author information\n    const { data, error } = await supabase\n      .from('messages')\n      .select(`\n        id,\n        user_id,\n        content,\n        created_at,\n        profiles!inner (\n          username,\n          avatar_url\n        )\n      `)\n      .order('created_at', { ascending: false })\n      .limit(100)\n    \n    if (error) {\n      throw new Error(`Failed to fetch messages: ${error.message}`)\n    }\n    \n    // Map Supabase data to domain Message entity\n    return data.map(msg => ({\n      id: msg.id,\n      userId: msg.user_id,\n      content: msg.content,\n      createdAt: new Date(msg.created_at),\n      author: {\n        username: msg.profiles.username,\n        avatarUrl: msg.profiles.avatar_url\n      }\n    })).reverse() // Reverse to show oldest first\n  }\n\n  async sendMessage(content: string): Promise<Message> {\n    const supabase = createBrowserClient()\n    \n    // Get current authenticated user\n    const { data: { user } } = await supabase.auth.getUser()\n    if (!user) {\n      throw new Error('User must be authenticated to send messages')\n    }\n    \n    // Insert message (RLS policy enforces user_id = auth.uid())\n    const { data, error } = await supabase\n      .from('messages')\n      .insert({\n        user_id: user.id,\n        content\n      })\n      .select(`\n        id,\n        user_id,\n        content,\n        created_at,\n        profiles!inner (\n          username,\n          avatar_url\n        )\n      `)\n      .single()\n    \n    if (error) {\n      throw new Error(`Failed to send message: ${error.message}`)\n    }\n    \n    return {\n      id: data.id,\n      userId: data.user_id,\n      content: data.content,\n      createdAt: new Date(data.created_at),\n      author: {\n        username: data.profiles.username,\n        avatarUrl: data.profiles.avatar_url\n      }\n    }\n  }\n\n  async deleteMessage(id: string): Promise<void> {\n    const supabase = createBrowserClient()\n    \n    // RLS policy ensures user can only delete their own messages\n    const { error } = await supabase\n      .from('messages')\n      .delete()\n      .eq('id', id)\n    \n    if (error) {\n      throw new Error(`Failed to delete message: ${error.message}`)\n    }\n  }\n\n  subscribeToMessages(callback: (message: Message) => void): { unsubscribe: () => void } {\n    const supabase = createBrowserClient()\n    \n    // Subscribe to all changes on messages table\n    const channel: RealtimeChannel = supabase\n      .channel('messages')\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'messages'\n        },\n        async (payload) => {\n          // For INSERT/UPDATE events, fetch full message with author info\n          if (payload.eventType === 'INSERT' || payload.eventType === 'UPDATE') {\n            const { data } = await supabase\n              .from('messages')\n              .select(`\n                id,\n                user_id,\n                content,\n                created_at,\n                profiles!inner (\n                  username,\n                  avatar_url\n                )\n              `)\n              .eq('id', payload.new.id)\n              .single()\n            \n            if (data) {\n              callback({\n                id: data.id,\n                userId: data.user_id,\n                content: data.content,\n                createdAt: new Date(data.created_at),\n                author: {\n                  username: data.profiles.username,\n                  avatarUrl: data.profiles.avatar_url\n                }\n              })\n            }\n          }\n        }\n      )\n      .subscribe()\n    \n    return {\n      unsubscribe: () => {\n        supabase.removeChannel(channel)\n      }\n    }\n  }\n}\n\n// Export singleton instance\nexport const messageRepository = new SupabaseMessageRepository()\n```\n\nKey implementation details:\n- JOIN messages with profiles to get author information in single query\n- Use Supabase Realtime for real-time message updates\n- RLS policies enforce authentication and ownership rules\n- Map between Supabase snake_case and domain camelCase\n- Limit to 100 most recent messages for performance",
            "status": "pending",
            "testStrategy": "Integration tests with test Supabase instance:\n1. Test getMessages returns array of messages with author info\n2. Test getMessages orders by created_at DESC and limits to 100\n3. Test getMessages returns empty array when no messages exist\n4. Test getMessages handles database errors gracefully\n5. Test sendMessage creates message with current user's ID\n6. Test sendMessage returns message with author information\n7. Test sendMessage throws error when user not authenticated\n8. Test sendMessage respects RLS INSERT policy (auth required)\n9. Test deleteMessage successfully deletes own message\n10. Test deleteMessage respects RLS DELETE policy (own messages only)\n11. Test deleteMessage fails when trying to delete another user's message\n12. Test subscribeToMessages fires callback on INSERT events\n13. Test subscribeToMessages callback receives full message with author\n14. Test unsubscribe stops receiving updates\n15. Test real-time subscription handles connection errors\n16. Mock Supabase client for unit tests\n17. Test concurrent message sends don't cause race conditions",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create chat presentation layer hooks with TanStack Query and real-time subscription integration",
            "description": "Implement React hooks for chat operations with TanStack Query for caching and mutations, including real-time subscription handling, optimistic updates for sending messages, and proper cache invalidation.",
            "dependencies": [
              2
            ],
            "details": "Create presentation hooks in src/features/chat/presentation/hooks/:\n\n1. use-messages.ts - Query hook with real-time subscription:\n```typescript\nimport { useQuery, useQueryClient } from '@tanstack/react-query'\nimport { useEffect } from 'react'\nimport { messageRepository } from '../../infrastructure/supabase-message-repository'\nimport { getMessages } from '../../domain/use-cases/get-messages'\nimport { subscribeToMessages } from '../../domain/use-cases/subscribe-to-messages'\n\nexport function useMessages() {\n  const queryClient = useQueryClient()\n  \n  // Query for initial messages\n  const query = useQuery({\n    queryKey: ['messages'],\n    queryFn: () => getMessages(messageRepository),\n    staleTime: 0, // Always considered stale since we rely on real-time updates\n  })\n  \n  // Subscribe to real-time updates\n  useEffect(() => {\n    const subscription = subscribeToMessages(\n      messageRepository,\n      (message) => {\n        // Invalidate and refetch to get latest messages\n        queryClient.invalidateQueries({ queryKey: ['messages'] })\n      }\n    )\n    \n    return () => subscription.unsubscribe()\n  }, [queryClient])\n  \n  return query\n}\n```\n\n2. use-send-message.ts - Mutation hook with optimistic updates:\n```typescript\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { useAuth } from '@/features/auth/presentation/hooks/use-auth'\nimport { messageRepository } from '../../infrastructure/supabase-message-repository'\nimport { sendMessage } from '../../domain/use-cases/send-message'\nimport { Message } from '../../domain/entities/message'\n\nexport function useSendMessage() {\n  const queryClient = useQueryClient()\n  const { user } = useAuth()\n  \n  return useMutation({\n    mutationFn: (content: string) => sendMessage(messageRepository, content),\n    \n    onMutate: async (content) => {\n      // Cancel outgoing queries to prevent overwriting optimistic update\n      await queryClient.cancelQueries({ queryKey: ['messages'] })\n      \n      // Snapshot previous value\n      const previousMessages = queryClient.getQueryData<Message[]>(['messages'])\n      \n      // Optimistically add new message\n      if (previousMessages && user) {\n        const optimisticMessage: Message = {\n          id: `temp-${Date.now()}`,\n          userId: user.id,\n          content,\n          createdAt: new Date(),\n          author: {\n            username: user.username,\n            avatarUrl: user.avatarUrl\n          }\n        }\n        \n        queryClient.setQueryData<Message[]>(\n          ['messages'],\n          [...previousMessages, optimisticMessage]\n        )\n      }\n      \n      return { previousMessages }\n    },\n    \n    onError: (error, variables, context) => {\n      // Rollback on error\n      if (context?.previousMessages) {\n        queryClient.setQueryData(['messages'], context.previousMessages)\n      }\n    },\n    \n    onSuccess: () => {\n      // Real-time subscription will handle the update,\n      // but invalidate to ensure consistency\n      queryClient.invalidateQueries({ queryKey: ['messages'] })\n    }\n  })\n}\n```\n\n3. use-delete-message.ts - Mutation hook for deleting messages:\n```typescript\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { messageRepository } from '../../infrastructure/supabase-message-repository'\nimport { deleteMessage } from '../../domain/use-cases/delete-message'\nimport { Message } from '../../domain/entities/message'\n\nexport function useDeleteMessage() {\n  const queryClient = useQueryClient()\n  \n  return useMutation({\n    mutationFn: (messageId: string) => deleteMessage(messageRepository, messageId),\n    \n    onMutate: async (messageId) => {\n      // Cancel outgoing queries\n      await queryClient.cancelQueries({ queryKey: ['messages'] })\n      \n      // Snapshot previous value\n      const previousMessages = queryClient.getQueryData<Message[]>(['messages'])\n      \n      // Optimistically remove message\n      if (previousMessages) {\n        queryClient.setQueryData<Message[]>(\n          ['messages'],\n          previousMessages.filter(msg => msg.id !== messageId)\n        )\n      }\n      \n      return { previousMessages }\n    },\n    \n    onError: (error, variables, context) => {\n      // Rollback on error\n      if (context?.previousMessages) {\n        queryClient.setQueryData(['messages'], context.previousMessages)\n      }\n    },\n    \n    onSuccess: () => {\n      // Real-time subscription will handle the update\n      queryClient.invalidateQueries({ queryKey: ['messages'] })\n    }\n  })\n}\n```\n\nThese hooks provide:\n- Automatic caching and refetching with TanStack Query\n- Real-time updates via Supabase subscriptions\n- Optimistic updates for instant UI feedback\n- Proper error handling and rollback\n- Query invalidation for consistency",
            "status": "pending",
            "testStrategy": "Component tests using React Testing Library and renderHook:\n1. Test useMessages fetches messages on mount\n2. Test useMessages returns loading state initially\n3. Test useMessages returns messages data on success\n4. Test useMessages returns error state on failure\n5. Test useMessages subscribes to real-time updates on mount\n6. Test useMessages unsubscribes on unmount\n7. Test useMessages invalidates cache when subscription receives update\n8. Test useSendMessage successfully sends message\n9. Test useSendMessage shows optimistic message immediately\n10. Test useSendMessage optimistic message includes current user info\n11. Test useSendMessage rolls back on error\n12. Test useSendMessage invalidates cache on success\n13. Test useSendMessage validates empty/whitespace messages\n14. Test useDeleteMessage successfully deletes message\n15. Test useDeleteMessage optimistically removes message from UI\n16. Test useDeleteMessage rolls back on error (e.g., deleting another user's message)\n17. Test concurrent sends don't cause race conditions\n18. Mock repository to verify use case calls\n19. Test real-time subscription updates trigger cache invalidation\n20. Verify TypeScript types for all hooks",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Build chat UI components with message list, input form, and real-time features",
            "description": "Create chat UI components including MessageItem for displaying individual messages with avatars and delete functionality, MessageList with auto-scroll and date separators, and MessageInput with textarea, character limit, and keyboard shortcuts using shadcn/ui components.",
            "dependencies": [
              3
            ],
            "details": "Install required shadcn/ui components:\n```bash\nnpx shadcn add textarea\nnpx shadcn add scroll-area\nnpx shadcn add separator\n```\n\n1. Create src/features/chat/presentation/components/message-item.tsx:\n```typescript\nimport { Avatar, AvatarFallback, AvatarImage } from '@/shared/ui/avatar'\nimport { Button } from '@/shared/ui/button'\nimport { Trash2 } from 'lucide-react'\nimport { Message } from '../../domain/entities/message'\nimport { useAuth } from '@/features/auth/presentation/hooks/use-auth'\nimport { useDeleteMessage } from '../hooks/use-delete-message'\nimport { formatDistanceToNow } from 'date-fns'\n\ninterface MessageItemProps {\n  message: Message\n}\n\nexport function MessageItem({ message }: MessageItemProps) {\n  const { user } = useAuth()\n  const { mutate: deleteMessage, isPending } = useDeleteMessage()\n  const isOwnMessage = user?.id === message.userId\n  \n  const handleDelete = () => {\n    if (confirm('Delete this message?')) {\n      deleteMessage(message.id)\n    }\n  }\n  \n  const timestamp = formatDistanceToNow(message.createdAt, { addSuffix: true })\n  \n  return (\n    <div className={`flex gap-3 p-3 hover:bg-muted/50 group ${isOwnMessage ? 'flex-row-reverse' : ''}`}>\n      <Avatar className=\"h-10 w-10\">\n        <AvatarImage src={message.author.avatarUrl || undefined} />\n        <AvatarFallback>{message.author.username.charAt(0).toUpperCase()}</AvatarFallback>\n      </Avatar>\n      \n      <div className={`flex-1 ${isOwnMessage ? 'text-right' : ''}`}>\n        <div className=\"flex items-baseline gap-2 mb-1\">\n          <span className=\"font-semibold text-sm\">{message.author.username}</span>\n          <span className=\"text-xs text-muted-foreground\">{timestamp}</span>\n          {isOwnMessage && (\n            <Button\n              variant=\"ghost\"\n              size=\"icon\"\n              className=\"h-6 w-6 opacity-0 group-hover:opacity-100 transition-opacity\"\n              onClick={handleDelete}\n              disabled={isPending}\n            >\n              <Trash2 className=\"h-3 w-3\" />\n            </Button>\n          )}\n        </div>\n        <div className={`text-sm whitespace-pre-wrap break-words ${isOwnMessage ? 'bg-primary text-primary-foreground' : 'bg-muted'} rounded-lg px-3 py-2 inline-block max-w-[70%]`}>\n          {message.content}\n        </div>\n      </div>\n    </div>\n  )\n}\n```\n\n2. Create src/features/chat/presentation/components/message-list.tsx:\n```typescript\nimport { ScrollArea } from '@/shared/ui/scroll-area'\nimport { Separator } from '@/shared/ui/separator'\nimport { MessageItem } from './message-item'\nimport { Message } from '../../domain/entities/message'\nimport { useMessages } from '../hooks/use-messages'\nimport { Loader2 } from 'lucide-react'\nimport { useEffect, useRef } from 'react'\nimport { format, isSameDay } from 'date-fns'\n\nexport function MessageList() {\n  const { data: messages, isLoading, error } = useMessages()\n  const scrollRef = useRef<HTMLDivElement>(null)\n  \n  // Auto-scroll to bottom when new messages arrive\n  useEffect(() => {\n    if (scrollRef.current) {\n      scrollRef.current.scrollTop = scrollRef.current.scrollHeight\n    }\n  }, [messages])\n  \n  if (isLoading) {\n    return (\n      <div className=\"flex-1 flex items-center justify-center\">\n        <Loader2 className=\"h-8 w-8 animate-spin\" />\n      </div>\n    )\n  }\n  \n  if (error) {\n    return (\n      <div className=\"flex-1 flex items-center justify-center\">\n        <div className=\"text-center text-muted-foreground\">\n          <p>Failed to load messages</p>\n          <p className=\"text-sm\">{error.message}</p>\n        </div>\n      </div>\n    )\n  }\n  \n  if (!messages || messages.length === 0) {\n    return (\n      <div className=\"flex-1 flex items-center justify-center\">\n        <p className=\"text-muted-foreground\">No messages yet. Start the conversation!</p>\n      </div>\n    )\n  }\n  \n  // Group messages by date for separators\n  const messageGroups: { date: Date; messages: Message[] }[] = []\n  messages.forEach((message) => {\n    const lastGroup = messageGroups[messageGroups.length - 1]\n    if (!lastGroup || !isSameDay(lastGroup.date, message.createdAt)) {\n      messageGroups.push({ date: message.createdAt, messages: [message] })\n    } else {\n      lastGroup.messages.push(message)\n    }\n  })\n  \n  return (\n    <ScrollArea className=\"flex-1\" ref={scrollRef}>\n      <div className=\"flex flex-col\">\n        {messageGroups.map((group, groupIndex) => (\n          <div key={groupIndex}>\n            <div className=\"flex items-center gap-2 py-2 px-4\">\n              <Separator className=\"flex-1\" />\n              <span className=\"text-xs text-muted-foreground\">\n                {format(group.date, 'MMMM d, yyyy')}\n              </span>\n              <Separator className=\"flex-1\" />\n            </div>\n            {group.messages.map((message) => (\n              <MessageItem key={message.id} message={message} />\n            ))}\n          </div>\n        ))}\n      </div>\n    </ScrollArea>\n  )\n}\n```\n\n3. Create src/features/chat/presentation/components/message-input.tsx:\n```typescript\nimport { Textarea } from '@/shared/ui/textarea'\nimport { Button } from '@/shared/ui/button'\nimport { Send } from 'lucide-react'\nimport { useSendMessage } from '../hooks/use-send-message'\nimport { useState, KeyboardEvent } from 'react'\nimport { useToast } from '@/shared/ui/use-toast'\n\nconst MAX_MESSAGE_LENGTH = 2000\n\nexport function MessageInput() {\n  const [content, setContent] = useState('')\n  const { mutate: sendMessage, isPending } = useSendMessage()\n  const { toast } = useToast()\n  \n  const handleSubmit = () => {\n    if (!content.trim()) return\n    \n    sendMessage(content, {\n      onSuccess: () => {\n        setContent('')\n      },\n      onError: (error) => {\n        toast({\n          title: 'Failed to send message',\n          description: error.message,\n          variant: 'destructive'\n        })\n      }\n    })\n  }\n  \n  const handleKeyDown = (e: KeyboardEvent<HTMLTextAreaElement>) => {\n    // Send on Enter, new line on Shift+Enter\n    if (e.key === 'Enter' && !e.shiftKey) {\n      e.preventDefault()\n      handleSubmit()\n    }\n  }\n  \n  const remaining = MAX_MESSAGE_LENGTH - content.length\n  const isOverLimit = remaining < 0\n  \n  return (\n    <div className=\"border-t p-4\">\n      <div className=\"flex gap-2\">\n        <div className=\"flex-1\">\n          <Textarea\n            placeholder=\"Type a message... (Enter to send, Shift+Enter for new line)\"\n            value={content}\n            onChange={(e) => setContent(e.target.value)}\n            onKeyDown={handleKeyDown}\n            disabled={isPending}\n            rows={3}\n            className=\"resize-none\"\n          />\n          <div className={`text-xs mt-1 ${isOverLimit ? 'text-destructive' : 'text-muted-foreground'}`}>\n            {remaining} characters remaining\n          </div>\n        </div>\n        <Button\n          onClick={handleSubmit}\n          disabled={isPending || !content.trim() || isOverLimit}\n          size=\"icon\"\n          className=\"h-[74px]\"\n        >\n          <Send className=\"h-4 w-4\" />\n        </Button>\n      </div>\n    </div>\n  )\n}\n```\n\nInstall date-fns for timestamp formatting:\n```bash\npnpm add date-fns\n```\n\nComponents include:\n- Avatar with fallback to username initial\n- Timestamp with relative time (e.g., \"2 minutes ago\")\n- Delete button visible on hover for own messages\n- Auto-scroll to bottom on new messages\n- Date separators between message groups\n- Character counter with visual feedback\n- Keyboard shortcuts (Enter to send, Shift+Enter for new line)\n- Loading and error states",
            "status": "pending",
            "testStrategy": "Component tests with React Testing Library:\n1. Test MessageItem renders avatar, username, and content\n2. Test MessageItem shows timestamp in relative format\n3. Test MessageItem delete button only visible for own messages\n4. Test MessageItem delete button triggers delete mutation\n5. Test MessageItem delete confirmation dialog appears\n6. Test MessageItem styling differs for own vs others' messages\n7. Test MessageItem preserves line breaks in content\n8. Test MessageList renders all messages correctly\n9. Test MessageList shows loading spinner while fetching\n10. Test MessageList shows error message on fetch failure\n11. Test MessageList shows empty state when no messages\n12. Test MessageList groups messages by date with separators\n13. Test MessageList auto-scrolls to bottom on new message\n14. Test MessageList scroll position maintained when viewing history\n15. Test MessageInput allows typing and shows character count\n16. Test MessageInput sends message on Enter key\n17. Test MessageInput adds new line on Shift+Enter\n18. Test MessageInput disabled when sending\n19. Test MessageInput clears after successful send\n20. Test MessageInput shows error toast on send failure\n21. Test MessageInput disables send button when empty\n22. Test MessageInput shows warning when character limit exceeded\n23. Test MessageInput prevents sending when over limit\n24. Verify accessibility: ARIA labels, keyboard navigation\n25. Test responsive behavior on mobile screens",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create chat page with layout, connection status, and integrate all chat components",
            "description": "Implement the main chat page (/chat or /) with authentication guard, responsive layout integrating MessageList and MessageInput, real-time connection status indicator, and error boundaries for graceful error handling.",
            "dependencies": [
              4
            ],
            "details": "1. Create src/app/chat/page.tsx (or src/app/page.tsx as main page):\n```typescript\n'use client'\n\nimport { useRequireAuth } from '@/features/auth/presentation/hooks/use-require-auth'\nimport { MessageList } from '@/features/chat/presentation/components/message-list'\nimport { MessageInput } from '@/features/chat/presentation/components/message-input'\nimport { useEffect, useState } from 'react'\nimport { createClient } from '@/infrastructure/supabase/client'\nimport { Wifi, WifiOff } from 'lucide-react'\n\nexport default function ChatPage() {\n  // Redirect to login if not authenticated\n  useRequireAuth()\n  \n  const [isConnected, setIsConnected] = useState(true)\n  \n  // Monitor real-time connection status\n  useEffect(() => {\n    const supabase = createClient()\n    \n    // Subscribe to connection state changes\n    const channel = supabase.channel('connection-status')\n    \n    channel.on('system', { event: 'connection_change' }, (payload) => {\n      setIsConnected(payload.connected)\n    })\n    \n    channel.subscribe((status) => {\n      if (status === 'SUBSCRIBED') {\n        setIsConnected(true)\n      } else if (status === 'CLOSED' || status === 'CHANNEL_ERROR') {\n        setIsConnected(false)\n      }\n    })\n    \n    return () => {\n      supabase.removeChannel(channel)\n    }\n  }, [])\n  \n  return (\n    <div className=\"flex flex-col h-[calc(100vh-4rem)]\">\n      {/* Connection status indicator */}\n      {!isConnected && (\n        <div className=\"bg-destructive text-destructive-foreground px-4 py-2 text-sm flex items-center gap-2\">\n          <WifiOff className=\"h-4 w-4\" />\n          <span>Connection lost. Reconnecting...</span>\n        </div>\n      )}\n      \n      {isConnected && (\n        <div className=\"bg-green-500/10 text-green-700 dark:text-green-400 px-4 py-1 text-xs flex items-center gap-2\">\n          <Wifi className=\"h-3 w-3\" />\n          <span>Connected</span>\n        </div>\n      )}\n      \n      {/* Message list - takes remaining space */}\n      <MessageList />\n      \n      {/* Message input - fixed at bottom */}\n      <MessageInput />\n    </div>\n  )\n}\n```\n\n2. Create error boundary wrapper (src/shared/components/error-boundary.tsx):\n```typescript\n'use client'\n\nimport { Component, ErrorInfo, ReactNode } from 'react'\nimport { Button } from '@/shared/ui/button'\nimport { AlertCircle } from 'lucide-react'\n\ninterface Props {\n  children: ReactNode\n  fallback?: ReactNode\n}\n\ninterface State {\n  hasError: boolean\n  error?: Error\n}\n\nexport class ErrorBoundary extends Component<Props, State> {\n  constructor(props: Props) {\n    super(props)\n    this.state = { hasError: false }\n  }\n  \n  static getDerivedStateFromError(error: Error): State {\n    return { hasError: true, error }\n  }\n  \n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    console.error('Error boundary caught:', error, errorInfo)\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      return this.props.fallback || (\n        <div className=\"flex flex-col items-center justify-center min-h-[400px] p-8 text-center\">\n          <AlertCircle className=\"h-12 w-12 text-destructive mb-4\" />\n          <h2 className=\"text-2xl font-bold mb-2\">Something went wrong</h2>\n          <p className=\"text-muted-foreground mb-4\">\n            {this.state.error?.message || 'An unexpected error occurred'}\n          </p>\n          <Button onClick={() => this.setState({ hasError: false })}>\n            Try again\n          </Button>\n        </div>\n      )\n    }\n    \n    return this.props.children\n  }\n}\n```\n\n3. Wrap chat page with error boundary in layout:\n```typescript\n// Update src/app/chat/layout.tsx (or src/app/layout.tsx)\nimport { ErrorBoundary } from '@/shared/components/error-boundary'\n\nexport default function ChatLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <ErrorBoundary>\n      {children}\n    </ErrorBoundary>\n  )\n}\n```\n\n4. Update routing configuration if needed:\n- If using /chat route, ensure middleware protects it\n- If using / as main page, redirect authenticated users from /login to /\n\n5. Add toast provider to root layout (if not already added):\n```bash\nnpx shadcn add toast\n```\n\n```typescript\n// In src/app/layout.tsx\nimport { Toaster } from '@/shared/ui/toaster'\n\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <AuthProvider>\n          <Header />\n          <main>{children}</main>\n          <Toaster />\n        </AuthProvider>\n      </body>\n    </html>\n  )\n}\n```\n\nFeatures:\n- Full-height layout that fits viewport\n- Connection status indicator with visual feedback\n- Error boundary for graceful error handling\n- Responsive design that works on mobile/tablet/desktop\n- Auto-reconnection handling\n- Toast notifications for errors",
            "status": "pending",
            "testStrategy": "Integration and E2E testing:\n1. Test chat page redirects to /login when not authenticated\n2. Test chat page renders MessageList and MessageInput when authenticated\n3. Test chat page shows connection status indicator\n4. Test connection status changes when network disconnects\n5. Test connection status shows \"Connected\" when online\n6. Test connection status shows \"Connection lost\" when offline\n7. Test auto-reconnection when network restored\n8. Test error boundary catches and displays errors\n9. Test error boundary \"Try again\" button resets state\n10. Test complete message flow:\n    - User A sends message\n    - Message appears in User A's list (optimistic)\n    - Message appears in User B's list (real-time)\n    - User A deletes message\n    - Message removed from both users' lists\n11. Test layout is responsive on mobile (320px width)\n12. Test layout on tablet (768px width)\n13. Test layout on desktop (1920px width)\n14. Test MessageList scrolls correctly with many messages\n15. Test MessageInput stays fixed at bottom during scroll\n16. Test keyboard navigation through all interactive elements\n17. Test multi-user scenario: 5 users chatting simultaneously\n18. Test network interruption recovery:\n    - Disconnect network\n    - Send messages (should queue)\n    - Reconnect network\n    - Verify messages sent\n19. Test RLS policy enforcement:\n    - Try to delete another user's message (should fail)\n    - Verify error message displayed\n20. Test performance with 100+ messages loaded\n21. Verify no memory leaks with real-time subscriptions\n22. Test accessibility: screen reader compatibility, ARIA labels\n23. Run Lighthouse audit (target score >90)",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement comprehensive testing, Storybook documentation, and production optimizations",
        "description": "Set up complete test coverage using Vitest for all layers (domain, infrastructure, presentation), create Storybook stories for UI components, implement error boundaries, loading states, SEO optimization, and prepare for production deployment.",
        "details": "1. Set up comprehensive test infrastructure:\n   vitest.config.ts - configure test environment, coverage\n   src/shared/testing/setup.ts - global test setup\n   src/shared/testing/mocks/ - mock factories for entities\n   src/shared/testing/test-utils.tsx - custom render with providers\n\n2. Write domain layer tests:\n   src/features/auth/domain/use-cases/__tests__/\n   src/features/profile/domain/use-cases/__tests__/\n   src/features/chat/domain/use-cases/__tests__/\n   - Test all use cases with mocked repositories\n   - Test validation logic\n   - Test error handling\n   - Aim for 90%+ coverage on domain layer\n\n3. Write infrastructure layer tests:\n   src/features/*/infrastructure/__tests__/\n   - Test repository implementations with test Supabase instance\n   - Test real-time subscription handling\n   - Test file upload logic\n   - Mock Supabase client for unit tests\n\n4. Write presentation layer tests:\n   src/features/*/presentation/components/__tests__/\n   src/features/*/presentation/hooks/__tests__/\n   - Test component rendering with React Testing Library\n   - Test user interactions (click, type, submit)\n   - Test hook behavior with renderHook\n   - Test optimistic updates\n   - Test error states\n\n5. Set up Storybook stories:\n   .storybook/main.ts - configure Vite builder\n   .storybook/preview.tsx - global decorators, themes\n   \n   Create stories for all UI components:\n   src/shared/components/ui/*.stories.tsx\n   src/features/*/presentation/components/*.stories.tsx\n   \n   Story examples:\n   - MessageItem: normal, own message, with/without avatar, long text\n   - ProfileAvatar: with image, without image, loading\n   - MessageInput: empty, with text, disabled, error\n   - ProfileEditForm: initial state, editing, submitting, error\n   \n   Use Storybook actions for event handlers\n   Use Storybook controls for props\n\n6. Add accessibility testing to Storybook:\n   pnpm add -D @storybook/addon-a11y\n   Configure a11y addon in .storybook/main.ts\n\n7. Implement error boundaries:\n   src/shared/components/error-boundary.tsx\n   - Catch React errors\n   - Display user-friendly error message\n   - Log to error tracking (optional)\n   - Reset button to recover\n   \n   Wrap app and feature sections with error boundaries\n\n8. Add loading states and skeletons:\n   src/shared/components/ui/skeleton.tsx (npx shadcn add skeleton)\n   - Loading skeleton for message list\n   - Loading skeleton for profile\n   - Suspense boundaries for async components\n\n9. Implement SEO optimization:\n   src/app/layout.tsx - metadata, viewport\n   src/app/page.tsx - Open Graph tags\n   - Proper page titles\n   - Meta descriptions\n   - Open Graph images\n\n10. Add production optimizations:\n   - next.config.js: enable compression, optimize images\n   - Implement React.memo for expensive components\n   - Code splitting for feature modules\n   - Lazy load non-critical components\n   - Configure Supabase connection pooling\n\n11. Create comprehensive E2E test (optional but recommended):\n   Install Playwright: pnpm add -D @playwright/test\n   tests/e2e/chat-flow.spec.ts:\n   - Login → Edit profile → Send message → Delete message → Logout\n\n12. Add performance monitoring:\n   - Web Vitals tracking\n   - Supabase query performance logging\n   - Real-time connection health monitoring\n\n13. Create documentation:\n   docs/ARCHITECTURE.md - explain DDD/Clean Architecture structure\n   docs/TESTING.md - testing guidelines and examples\n   docs/DEPLOYMENT.md - deployment instructions\n\n14. Set up CI/CD preparation:\n   .github/workflows/test.yml - run tests on PR\n   .github/workflows/lint.yml - ESLint and TypeScript checks\n   Add npm scripts:\n   - pnpm test:coverage\n   - pnpm lint\n   - pnpm build\n   - pnpm type-check\n\n15. Create production environment setup guide:\n   - Supabase project creation\n   - Environment variables for production\n   - Google OAuth configuration\n   - Migration deployment process",
        "testStrategy": "Final validation checklist:\n1. Run full test suite:\n   - pnpm test:coverage (target >80% coverage)\n   - pnpm test:integration\n   - pnpm test:e2e (if implemented)\n2. Run production build:\n   - pnpm build (no errors)\n   - pnpm start (verify production mode)\n3. Storybook verification:\n   - pnpm build-storybook\n   - Check all components render\n   - Verify a11y checks pass\n4. Manual testing checklist:\n   - Complete user flow: login → profile edit → chat → logout\n   - Test on Chrome desktop (primary target)\n   - Test with 10 concurrent users\n   - Test network interruption recovery\n   - Test all error states\n   - Verify responsive behavior\n5. Performance audit:\n   - Lighthouse score (target >90)\n   - Web Vitals within thresholds\n   - Bundle size analysis\n6. Security audit:\n   - RLS policies tested\n   - XSS protection verified\n   - CSRF protection (built into Supabase)\n   - Environment variables not exposed\n7. Accessibility audit:\n   - Keyboard navigation works\n   - Screen reader compatibility\n   - Color contrast meets WCAG AA\n8. Documentation review:\n   - README complete\n   - Architecture docs accurate\n   - Deployment guide tested\n9. Production readiness:\n   - Error boundaries tested\n   - Loading states polished\n   - SEO metadata complete\n   - Analytics ready (if needed)",
        "priority": "medium",
        "dependencies": [
          "5"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up comprehensive test infrastructure with Vitest and testing utilities",
            "description": "Configure Vitest test environment, create global test setup files, implement custom render utilities with providers, and set up mock factories for domain entities to support testing across all layers.",
            "dependencies": [],
            "details": "Create vitest.config.ts with proper configuration for Next.js App Router environment including path aliases, coverage settings (threshold 80%+), and test environment setup. Implement src/shared/testing/setup.ts for global test configuration including @testing-library/jest-dom matchers and mock setup. Create src/shared/testing/test-utils.tsx with custom render function that wraps components with necessary providers (TanStack Query, Auth context). Build src/shared/testing/mocks/ directory with factory functions for creating test instances of domain entities (User, Profile, Message). Install required dependencies: vitest, @testing-library/react, @testing-library/jest-dom, @testing-library/user-event, @vitest/ui, happy-dom or jsdom.",
            "status": "pending",
            "testStrategy": "Verify vitest.config.ts is properly configured by running 'pnpm vitest --run'. Ensure test-utils.tsx custom render works by creating a simple component test. Validate mock factories produce valid entity instances matching domain types.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Write comprehensive tests for domain, infrastructure, and presentation layers",
            "description": "Implement unit tests for all use cases in domain layer, integration tests for repository implementations in infrastructure layer, and component/hook tests for presentation layer using React Testing Library.",
            "dependencies": [
              1
            ],
            "details": "Domain layer tests: Create __tests__ directories in src/features/auth/domain/use-cases/, src/features/profile/domain/use-cases/, src/features/chat/domain/use-cases/. Test all use cases with mocked repositories, validation logic, and error handling. Target 90%+ coverage on domain layer. Infrastructure layer tests: Create __tests__ in src/features/*/infrastructure/. Test repository implementations with mocked Supabase client, real-time subscription handling, and file upload logic. Presentation layer tests: Create __tests__ in src/features/*/presentation/components/ and src/features/*/presentation/hooks/. Test component rendering, user interactions (click, type, submit), hook behavior with renderHook, optimistic updates, and error states. Use React Testing Library best practices (query by role, accessible queries).",
            "status": "pending",
            "testStrategy": "Run 'pnpm test:coverage' and verify coverage exceeds 80% across all layers. Execute 'pnpm vitest --ui' to review test results visually. Ensure all critical paths (auth flow, message CRUD, profile updates) are covered. Validate error boundary and loading state tests catch edge cases.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Set up Storybook with stories for all UI components and accessibility testing",
            "description": "Configure Storybook with Vite builder for Next.js, create comprehensive stories for all shared and feature UI components with multiple variants, and integrate accessibility testing addon.",
            "dependencies": [
              1
            ],
            "details": "Install Storybook dependencies: @storybook/react, @storybook/addon-essentials, @storybook/addon-a11y, @storybook/addon-interactions, storybook. Initialize with 'npx storybook@latest init --builder vite'. Configure .storybook/main.ts with proper Vite integration and addons. Create .storybook/preview.tsx with global decorators (Tailwind CSS, theme provider, TanStack Query provider). Write stories for shadcn/ui components in src/shared/components/ui/*.stories.tsx (Button, Input, Avatar, Card, etc.). Create feature component stories in src/features/*/presentation/components/*.stories.tsx including MessageItem (normal, own message, with/without avatar, long text), ProfileAvatar (with image, without image, loading), MessageInput (empty, with text, disabled, error), ProfileEditForm (initial, editing, submitting, error). Use Storybook actions for event handlers and controls for props. Configure a11y addon for automatic accessibility checks.",
            "status": "pending",
            "testStrategy": "Run 'pnpm storybook' and verify all stories load without errors. Check that components render correctly with different prop combinations. Validate a11y addon reports no critical accessibility issues. Test interactive stories with addon-interactions work properly.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement production-ready error handling, loading states, and SEO optimization",
            "description": "Create error boundary components for graceful error recovery, implement loading skeletons and suspense boundaries, and add comprehensive SEO metadata with Open Graph tags.",
            "dependencies": [
              2
            ],
            "details": "Error boundaries: Create src/shared/components/error-boundary.tsx with React error boundary implementation that catches errors, displays user-friendly message, logs to console (or error tracking service), and provides reset button. Wrap app in src/app/layout.tsx and feature sections with error boundaries. Loading states: Install shadcn skeleton component ('npx shadcn add skeleton'). Create loading skeletons in src/shared/components/ui/skeleton.tsx for message list, profile page, and other async content. Add Suspense boundaries in route files for async Server Components. SEO optimization: Update src/app/layout.tsx with comprehensive metadata including title template, description, viewport configuration, and robots settings. Add Open Graph tags for social sharing (og:title, og:description, og:image, og:type). Create route-specific metadata in page.tsx files. Implement generateMetadata for dynamic pages.",
            "status": "pending",
            "testStrategy": "Test error boundary by throwing intentional errors in components and verifying user-friendly error UI appears. Validate loading skeletons display during async operations. Check SEO metadata using browser dev tools and Open Graph validators. Run Lighthouse audit for SEO score.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add production optimizations, CI/CD preparation, and comprehensive documentation",
            "description": "Implement performance optimizations (React.memo, code splitting, lazy loading), configure production environment settings, create CI/CD workflow files, and write architecture and deployment documentation.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Production optimizations: Configure next.config.js with compression, image optimization, and production-ready settings. Add React.memo to expensive components (MessageList, ProfileForm). Implement code splitting for feature modules using dynamic imports. Lazy load non-critical components with React.lazy and Suspense. Configure Supabase connection pooling settings. Add Web Vitals tracking in src/app/layout.tsx. Create performance monitoring utilities for Supabase query logging and real-time connection health. CI/CD preparation: Create .github/workflows/test.yml for running tests on PRs. Create .github/workflows/lint.yml for ESLint and TypeScript checks. Add npm scripts in package.json: test:coverage, test:integration, lint, build, type-check, storybook:build. Documentation: Create docs/ARCHITECTURE.md explaining DDD/Clean Architecture structure with diagrams. Write docs/TESTING.md with testing guidelines, examples, and best practices. Create docs/DEPLOYMENT.md with production deployment instructions including Supabase project setup, environment variables, Google OAuth configuration, and migration deployment process. Create docs/DEVELOPMENT.md for local setup guide.",
            "status": "pending",
            "testStrategy": "Final validation checklist: (1) Run 'pnpm test:coverage' and verify >80% coverage. (2) Run 'pnpm build' with zero errors and verify production build succeeds. (3) Run 'pnpm storybook:build' successfully. (4) Verify CI/CD workflows syntax with 'gh workflow list' or GitHub Actions validator. (5) Test production build locally with 'pnpm start'. (6) Run Lighthouse audit for performance, accessibility, and SEO scores (target 90+). (7) Verify all documentation files are complete and accurate.",
            "parentId": "undefined"
          }
        ]
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-19T01:57:25.018Z",
      "taskCount": 6,
      "completedCount": 2,
      "tags": [
        "master"
      ],
      "created": "2025-12-19T01:57:31.208Z",
      "description": "Tasks for master context"
    }
  }
}